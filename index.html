<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Gorgon Quest/Inventory Tracker</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>üó°Ô∏è Project Gorgon Quest/Inventory Tracker</h1>
            <p>Search your Quests, search your Inventory, track Vendor favor/limits</p>
        </header>

        <div class="nav">
            <b>Quest/Inventory Tracker</b>
            <a href="maps.html">Interactive Maps</a>
            <a href="chat-watcher.html">Chat Watcher</a>
        </div>

        <div class="file-loader">
            <div style="display: flex; gap: 10px; margin-bottom: 10px; align-items: center; flex-wrap: wrap;">
                <button id="selectFolderBtn" onclick="selectReportsFolder()" style="padding: 12px 16px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 1em; white-space: nowrap;">
                    üìÇ Select Folder
                </button>
                <button id="selectPlayerLogBtn" class="btn-secondary player-log-btn" onclick="selectPlayerLogFile()" style="padding: 12px 16px; white-space: nowrap;">
                    üìã Watch Player.log
                </button>
                <span id="reportsWatchStatus" style="font-size: 0.82em; color: #6c757d;"></span>
            </div>
            <div id="characterPickerRow" style="display:none; align-items:center; gap:8px; margin-bottom:10px;">
                <label style="font-weight:600; font-size:0.9em; white-space:nowrap; color:#495057;">Character:</label>
                <select id="characterPicker" style="flex:1; padding:6px 10px; border:1px solid #ced4da; border-radius:6px; font-size:0.9em; background:#fff; cursor:pointer;"></select>
            </div>
            <div style="font-size: 0.8em; color: #6c757d; margin-bottom: 10px;">
                Reports folder: <code style="background: #f0f0f0; padding: 1px 5px; border-radius: 3px;">%LocalAppData%Low\Elder Game\Project Gorgon\Reports</code>
            </div>
            <details style="margin-top: 10px;">
                <summary style="cursor: pointer; padding: 10px; background: #f8f9fa; border-radius: 6px; font-weight: 600;">Manual File Loading</summary>
                <div style="padding: 15px 0;">
                    <div class="file-input-group">
                        <label for="characterFile">Character Data:</label>
                        <input type="file" id="characterFile" accept=".json">
                    </div>
                    <div class="file-input-group">
                        <label for="itemsFile">Items Data:</label>
                        <input type="file" id="itemsFile" accept=".json">
                    </div>
                </div>
            </details>
            <div id="status" class="status"></div>
        </div>

        <div class="tabs">
            <div class="tab active" data-tab="quests">üìú Quests</div>
            <div class="tab" data-tab="inventory">üéí Inventory</div>
            <div class="tab" data-tab="stores">üõí Vendors</div>
            <div class="tab" data-tab="prices">üí∞ Prices</div>
        </div>

        <div id="quests" class="tab-content active quest-browser">
            <div id="questStats" class="quest-stats" style="display: none;">
                <div class="stat-card">
                    <div class="number" id="totalQuests">0</div>
                    <div class="label">Active Quests</div>
                </div>
                <div class="stat-card">
                    <div class="number" id="goldAmount">0</div>
                    <div class="label">Gold</div>
                </div>
            </div>

            <div id="questSearchBar" class="search-bar" style="display: none;">
                <input type="text" id="questSearch" placeholder="üîç Search quests by name, NPC, or description...">
            </div>

            <div id="questList" class="quest-list"></div>
        </div>

        <div id="inventory" class="tab-content inventory-browser">
            <div id="inventoryStats" class="quest-stats" style="display: none;">
                <div class="stat-card">
                    <div class="number" id="totalItems">0</div>
                    <div class="label">Total Items</div>
                </div>
                <div class="stat-card">
                    <div class="number" id="totalValue">0</div>
                    <div class="label">Total Value</div>
                </div>
                <div class="stat-card">
                    <div class="number" id="vaultCount">0</div>
                    <div class="label">Storage Vaults</div>
                </div>
            </div>

            <div id="inventorySearchBar" class="search-bar" style="display: none;">
                <input type="text" id="inventorySearch" placeholder="üîç Search items by name...">
            </div>

            <div id="inventoryList" class="quest-list"></div>
        </div>

        <div id="prices" class="tab-content vendor-price-browser">
            <div id="shopsSellCard" style="display:none;"></div>
            <div class="price-toolbar">
                <input type="text" id="priceSearch" class="price-search" placeholder="üîç Search tracked items...">
                <button class="btn-add-item" id="addItemBtn">+ Add Item</button>
            </div>
            <div class="price-log-hint">üí° If you're watching <strong>Player.log</strong>, querying the Search Golem in-game will automatically pop up a <em>Shops Selling</em> card here.</div>
            <div id="priceList"></div>
        </div>

        <div id="stores" class="tab-content stores-browser">
            <div id="storeList"></div>
        </div>
    </div>

    <script>
        // Data Loader
        class DataLoader {
            constructor() {
                this.characterData = null;
                this.itemsData = null;
                this.questsData = null;
                this.npcsData = null;
                this.cdnItemsData = null;
                this.storageVaultsData = null;
                this.cdnBaseUrl = 'https://cdn.projectgorgon.com/v459/data/';
            }

            async loadCharacterFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            this.characterData = JSON.parse(e.target.result);
                            resolve(this.characterData);
                        } catch (error) {
                            reject(new Error('Invalid JSON file'));
                        }
                    };
                    reader.onerror = () => reject(new Error('Failed to read file'));
                    reader.readAsText(file);
                });
            }

            async fetchCDNData(filename) {
                const url = this.cdnBaseUrl + filename;
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Failed to fetch ${filename}`);
                }
                return await response.json();
            }

            async loadQuestData() {
                // Check in-memory cache first
                if (this.questsData && this.npcsData) {
                    return; // Already loaded in this session
                }

                // Fetch from CDN
                const [questsRaw, npcsRaw] = await Promise.all([
                    this.fetchCDNData('quests.json'),
                    this.fetchCDNData('npcs.json')
                ]);

                // Process quests into keyed lookup by InternalName
                this.questsData = this.processToKeyedLookup(questsRaw, 'InternalName');

                // Process NPCs into keyed lookup (they might use a different key)
                this.npcsData = this.processToKeyedLookup(npcsRaw, 'InternalName') || npcsRaw;
            }

            processToKeyedLookup(data, keyField) {
                // If already an object (not array), check if it needs processing
                if (!Array.isArray(data)) {
                    // Check if it's already keyed properly
                    const firstKey = Object.keys(data)[0];
                    if (firstKey && data[firstKey] && data[firstKey][keyField] === firstKey) {
                        return data; // Already properly keyed
                    }
                    // If it's an object with values that have the keyField, rekey it
                    const result = {};
                    for (const value of Object.values(data)) {
                        if (value && value[keyField]) {
                            result[value[keyField]] = value;
                        }
                    }
                    return Object.keys(result).length > 0 ? result : data;
                }

                // Process array into keyed object
                const result = {};
                for (const item of data) {
                    if (item && item[keyField]) {
                        result[item[keyField]] = item;
                    }
                }
                return result;
            }

            getQuestDetails(internalName) {
                if (!this.questsData || !this.questsData[internalName]) {
                    return {
                        InternalName: internalName,
                        Name: internalName,
                        Description: 'Quest details not found',
                        Objectives: [],
                        IsCategoryGate: false
                    };
                }
                return this.questsData[internalName];
            }

            getNPCName(npcId) {
                // Regex replace to sanitize the prefix before the NPC name, for example: AreaEltibule/NPC_Mythander -> NPC_Mythander
                npcId = (npcId || '').replace(/^[^/]*\//, '').trim();

                if (!this.npcsData || !this.npcsData[npcId]) {
                    return null;
                }
                return this.npcsData[npcId].Name || npcId;
            }

            async resolveReportsDir(dirHandle) {
                // Check if this dir contains a Character_*.json file
                const hasCharFile = await (async () => {
                    for await (const [name, handle] of dirHandle.entries()) {
                        if (handle.kind === 'file' && name.startsWith('Character_') && name.endsWith('.json')) return true;
                    }
                    return false;
                })();
                if (hasCharFile) return dirHandle;

                // Try navigating into a Reports subdirectory
                try {
                    return await dirHandle.getDirectoryHandle('Reports');
                } catch (_) {
                    throw new Error('No Character_*.json found. Select the Reports folder (or its parent Project Gorgon folder).');
                }
            }

            async loadCharacterFromDirectory(dirHandle) {
                const reportsDir = await this.resolveReportsDir(dirHandle);
                this._reportsDir = reportsDir;

                // Find the most recently modified Character_*.json
                let latestHandle = null, latestMtime = 0;
                for await (const [name, handle] of reportsDir.entries()) {
                    if (handle.kind === 'file' && name.startsWith('Character_') && name.endsWith('.json')) {
                        const f = await handle.getFile();
                        if (f.lastModified > latestMtime) {
                            latestMtime = f.lastModified;
                            latestHandle = handle;
                            this._charFileBaseName = name.replace(/^Character_/, '').replace(/\.json$/, '');
                        }
                    }
                }
                if (!latestHandle) throw new Error('No Character_*.json found in selected folder');
                const file = await latestHandle.getFile();
                this.characterData = JSON.parse(await file.text());
                return this.characterData;
            }

            async loadItemsFromDirectory(dirHandle) {
                const reportsDir = this._reportsDir || await this.resolveReportsDir(dirHandle);
                // Use character base name (e.g. "Kaeus_SomeServer") derived from the character file
                const charBase = this._charFileBaseName || '';
                let latestHandle = null, latestName = '';
                for await (const [name, handle] of reportsDir.entries()) {
                    if (handle.kind === 'file' && name.endsWith('.json') &&
                        name.includes('_items_') &&
                        (charBase ? name.startsWith(charBase + '_items_') : true) &&
                        name > latestName) {
                        latestName = name;
                        latestHandle = handle;
                    }
                }
                if (!latestHandle) throw new Error('No *_items_*.json found in selected folder');
                const file = await latestHandle.getFile();
                this.itemsData = JSON.parse(await file.text());
                return this.itemsData;
            }

            async loadItemsFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            this.itemsData = JSON.parse(e.target.result);
                            resolve(this.itemsData);
                        } catch (error) {
                            reject(new Error('Invalid JSON file'));
                        }
                    };
                    reader.onerror = () => reject(new Error('Failed to read file'));
                    reader.readAsText(file);
                });
            }

            async loadInventoryData() {
                // Check in-memory cache first
                if (this.cdnItemsData && this.storageVaultsData) {
                    return; // Already loaded in this session
                }

                // Fetch from CDN
                const [itemsRaw, vaultsRaw] = await Promise.all([
                    this.fetchCDNData('items.json'),
                    this.fetchCDNData('storagevaults.json')
                ]);

                // Process into keyed lookups
                this.cdnItemsData = this.processToKeyedLookup(itemsRaw, 'InternalName');
                this.storageVaultsData = this.processToKeyedLookup(vaultsRaw, 'InternalName') || vaultsRaw;
            }

            getItemDetails(typeId) {
                if (!this.cdnItemsData) return null;

                // CDN items might be keyed by numeric ID or InternalName
                // Try direct lookup first
                let item = this.cdnItemsData[typeId];
                if (item) return item;

                // Search by Id field
                for (const itemData of Object.values(this.cdnItemsData)) {
                    if (itemData.Id === typeId) {
                        return itemData;
                    }
                }
                return null;
            }

            getVaultName(internalName) {
                if (!this.storageVaultsData || !this.storageVaultsData[internalName]) {
                    return internalName || 'Inventory';
                }
                return this.storageVaultsData[internalName].Name || internalName;
            }

            // Scan for all Character_*.json files; returns array sorted newest-first
            async scanCharacterFiles(reportsDir) {
                const characters = [];
                for await (const [name, handle] of reportsDir.entries()) {
                    if (handle.kind !== 'file' || !name.startsWith('Character_') || !name.endsWith('.json')) continue;
                    const baseName = name.replace(/^Character_/, '').replace(/\.json$/, '');
                    const parsed = parseCharacterBaseName(baseName);
                    const file = await handle.getFile();
                    characters.push({ filename: name, baseName, ...parsed, mtime: file.lastModified, handle });
                }
                characters.sort((a, b) => b.mtime - a.mtime);
                return characters;
            }

            // Load a specific character file by its already-resolved handle
            async loadCharacterFromHandle(handle, baseName) {
                this._charFileBaseName = baseName;
                const file = await handle.getFile();
                this.characterData = JSON.parse(await file.text());
                return this.characterData;
            }
        }

        // Quest Browser
        class QuestBrowser {
            constructor(dataLoader) {
                this.dataLoader = dataLoader;
                this.allQuests = [];
                this.filteredQuests = [];
            }

            async initialize() {
                if (!this.dataLoader.characterData || !this.dataLoader.questsData) {
                    return;
                }

                // Build quest list with details
                this.allQuests = this.dataLoader.characterData.ActiveQuests.map(internalName => {
                    const questData = this.dataLoader.getQuestDetails(internalName);
                    const npcName = this.dataLoader.getNPCName(questData.FavorNpc);

                    return {
                        internalName,
                        ...questData,
                        npcName
                    };
                });

                this.filteredQuests = [...this.allQuests];
                this.render();
                this.updateStats();
            }

            updateStats() {
                const characterData = this.dataLoader.characterData;

                document.getElementById('totalQuests').textContent = this.allQuests.length;
                document.getElementById('goldAmount').textContent = characterData.Currencies.GOLD.toLocaleString();

                document.getElementById('questStats').style.display = 'grid';
                document.getElementById('questSearchBar').style.display = 'block';
            }

            search(query) {
                const lowerQuery = query.toLowerCase();
                this.filteredQuests = this.allQuests.filter(quest => {
                    // Search in basic fields
                    if (quest.Name?.toLowerCase().includes(lowerQuery) ||
                        quest.Description?.toLowerCase().includes(lowerQuery) ||
                        quest.npcName?.toLowerCase().includes(lowerQuery) ||
                        quest.FavorNpc?.toLowerCase().includes(lowerQuery) ||
                        quest.internalName?.toLowerCase().includes(lowerQuery)) {
                        return true;
                    }

                    // Search in objectives
                    if (quest.Objectives && Array.isArray(quest.Objectives)) {
                        for (const obj of quest.Objectives) {
                            const objText = typeof obj === 'string' ? obj : JSON.stringify(obj);
                            if (objText.toLowerCase().includes(lowerQuery)) {
                                return true;
                            }
                        }
                    }

                    return false;
                });
                this.render();
            }

            buildQuickObjectives() {
                const objectivesByZone = {};

                for (const quest of this.filteredQuests) {
                    const zone = quest.DisplayedLocation || 'Unknown Location';
                    if (!objectivesByZone[zone]) {
                        objectivesByZone[zone] = [];
                    }

                    if (quest.Objectives && Array.isArray(quest.Objectives)) {
                        for (const objective of quest.Objectives) {
                            const objText = objective.Description || (typeof objective === 'string' ? objective : JSON.stringify(objective));

                            // Filter out "Talk to" or "Return to" objectives (turn-in objectives)
                            if (!(objText).match(/^(Talk to|Return to|Speak with|Speak to)/i)) {
                                objectivesByZone[zone].push({
                                    text: objText,
                                    questName: quest.Name
                                });
                            }
                        }
                    }
                }

                return objectivesByZone;
            }

            renderQuickObjectives() {
                const objectivesByZone = this.buildQuickObjectives();
                const zones = Object.keys(objectivesByZone).sort();

                if (zones.length === 0) {
                    return '';
                }

                const zonesHTML = zones.map((zone, index) => {
                    const objectives = objectivesByZone[zone];
                    if (objectives.length === 0) return '';

                    const zoneId = `quick-zone-${zone.replace(/\s+/g, '-').toLowerCase()}`;

                    return `
                        <div class="quick-objectives-zone">
                            <div class="quick-objectives-zone-header" data-zone="${zoneId}">
                                <div class="quick-objectives-zone-title">
                                    <span>üìç ${zone}</span>
                                    <span class="quest-count-badge">${objectives.length}</span>
                                </div>
                                <div class="accordion-icon">‚ñº</div>
                            </div>
                            <div id="${zoneId}" class="quick-objectives-zone-content">
                                <ul class="quick-objectives-list">
                                    ${objectives.map(obj => {
                                        const wikiSearchUrl = `https://wiki.projectgorgon.com/wiki/?search=${encodeURIComponent(obj.questName)}`;
                                        return `
                                            <li class="quick-objective-item">
                                                <span class="quick-objective-text">${obj.text}</span>
                                                <span class="quick-objective-quest"><a href="${wikiSearchUrl}" target="_blank" rel="noopener noreferrer">${obj.questName}</a></span>
                                            </li>
                                        `;
                                    }).join('')}
                                </ul>
                            </div>
                        </div>
                    `;
                }).join('');

                return `
                    <div class="quick-objectives-section">
                        <div class="quick-objectives-header" id="quickObjectivesToggle">
                            <div class="quick-objectives-title">
                                <span>‚ö° Quick Objectives</span>
                                <span class="quest-count-badge">${Object.values(objectivesByZone).flat().length} objectives</span>
                            </div>
                            <div class="accordion-icon">‚ñº</div>
                        </div>
                        <div class="quick-objectives-content active" id="quickObjectivesContent">
                            ${zonesHTML}
                        </div>
                    </div>
                `;
            }

            render() {
                const container = document.getElementById('questList');

                if (this.filteredQuests.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">üìú</div>
                            <h3>No quests found</h3>
                            <p>Try adjusting your search or load character data.</p>
                        </div>
                    `;
                    return;
                }

                // Build quick objectives section
                const quickObjectivesHTML = this.renderQuickObjectives();

                // Group quests by DisplayedLocation
                const groupedQuests = this.groupByLocation(this.filteredQuests);

                // Render quick objectives + accordions for each location
                container.innerHTML = quickObjectivesHTML + Object.entries(groupedQuests)
                    .sort(([a], [b]) => a.localeCompare(b))
                    .map(([location, quests]) => this.renderLocationAccordion(location, quests))
                    .join('');

                // Add click handlers for accordions
                this.attachAccordionHandlers();
            }

            groupByLocation(quests) {
                const grouped = {};
                for (const quest of quests) {
                    const location = quest.DisplayedLocation || 'Unknown Location';
                    if (!grouped[location]) {
                        grouped[location] = [];
                    }
                    grouped[location].push(quest);
                }
                return grouped;
            }

            renderLocationAccordion(location, quests) {
                const accordionId = `accordion-${location.replace(/\s+/g, '-').toLowerCase()}`;
                return `
                    <div class="location-accordion">
                        <div class="accordion-header" data-accordion="${accordionId}">
                            <div class="accordion-title">
                                <span>üìç ${location}</span>
                                <span class="quest-count-badge">${quests.length} quest${quests.length !== 1 ? 's' : ''}</span>
                            </div>
                            <div class="accordion-icon">‚ñº</div>
                        </div>
                        <div id="${accordionId}" class="accordion-content">
                            <div class="accordion-quests">
                                ${quests.map(quest => this.renderQuestCard(quest)).join('')}
                            </div>
                        </div>
                    </div>
                `;
            }

            attachAccordionHandlers() {
                const container = document.getElementById('questList');

                // Handle quest accordion headers
                const headers = container.querySelectorAll('.accordion-header');
                headers.forEach(header => {
                    header.addEventListener('click', () => {
                        const accordionId = header.getAttribute('data-accordion');
                        const content = document.getElementById(accordionId);

                        // Toggle active state
                        header.classList.toggle('active');
                        content.classList.toggle('active');
                    });
                });

                // Handle quick objectives toggle
                const quickObjToggle = document.getElementById('quickObjectivesToggle');
                if (quickObjToggle) {
                    quickObjToggle.addEventListener('click', () => {
                        const content = document.getElementById('quickObjectivesContent');
                        quickObjToggle.classList.toggle('active');
                        content.classList.toggle('active');
                    });
                }

                // Handle quick objectives zone toggles
                const zoneHeaders = container.querySelectorAll('.quick-objectives-zone-header');
                zoneHeaders.forEach(header => {
                    header.addEventListener('click', () => {
                        const zoneId = header.getAttribute('data-zone');
                        const content = document.getElementById(zoneId);
                        header.classList.toggle('active');
                        content.classList.toggle('active');
                    });
                });
            }

            renderQuestCard(quest) {
                const objectives = quest.Objectives || [];
                const rewards = this.formatRewards(quest);
                const level = quest.Level || quest.MidLevel || '?';
                const questName = quest.Name || quest.internalName;
                const wikiSearchUrl = `https://wiki.projectgorgon.com/wiki/?search=${encodeURIComponent(questName)}`;

                return `
                    <div class="quest-card">
                        <div class="quest-header">
                            <div>
                                <div class="quest-title"><a href="${wikiSearchUrl}" target="_blank" rel="noopener noreferrer">${questName}</a></div>
                                ${quest.npcName ? `<div class="quest-npc">üìç ${quest.npcName}</div>` : ''}
                            </div>
                            ${quest.Reward_Favor ? `<div class="quest-level">${quest.Reward_Favor}fv</div>` : ''}
                        </div>

                        ${quest.Description ? `<div class="quest-description">${quest.Description}</div>` : ''}

                        ${objectives.length > 0 ? `
                            <div class="quest-objectives">
                                <h4>Objectives</h4>
                                <ul>
                                    ${objectives.map(obj => `
                                        <li>${this.formatObjective(obj)}</li>
                                    `).join('')}
                                </ul>
                            </div>
                        ` : ''}

                        ${rewards.length > 0 ? `
                            <div class="quest-rewards">
                                ${rewards.map(reward => `<div class="reward-item">${reward}</div>`).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            formatObjective(objective) {
                if (typeof objective === 'string') return objective;
                if (objective.Description) return objective.Description;
                if (objective.Type) {
                    let text = objective.Type;
                    if (objective.Target) text += `: ${objective.Target}`;
                    if (objective.Number) text += ` (${objective.Number})`;
                    return text;
                }
                return JSON.stringify(objective);
            }

            formatRewards(quest) {
                const rewards = [];

                if (quest.Rewards_Gold) {
                    rewards.push(`üí∞ ${quest.Rewards_Gold} Gold`);
                }

                if (quest.Rewards_Favor) {
                    rewards.push(`‚≠ê ${quest.Rewards_Favor} Favor`);
                }

                if (quest.Rewards_XP) {
                    rewards.push(`üìà ${quest.Rewards_XP} XP`);
                }

                if (quest.Rewards_Items && quest.Rewards_Items.length > 0) {
                    rewards.push(`üéÅ ${quest.Rewards_Items.length} Item(s)`);
                }

                return rewards;
            }
        }

        // Inventory Browser
        class InventoryBrowser {
            constructor(dataLoader) {
                this.dataLoader = dataLoader;
                this.allItems = [];
                this.filteredItems = [];
            }

            async initialize() {
                if (!this.dataLoader.itemsData || !this.dataLoader.cdnItemsData) {
                    return;
                }

                // Build item list with details
                this.allItems = this.dataLoader.itemsData.Items.map(item => {
                    const itemDetails = this.dataLoader.getItemDetails(item.TypeID);
                    const vaultName = this.dataLoader.getVaultName(item.StorageVault);

                    return {
                        ...item,
                        details: itemDetails,
                        vaultName
                    };
                });

                this.filteredItems = [...this.allItems];
                this.render();
                this.updateStats();
            }

            updateStats() {
                const totalItems = this.allItems.reduce((sum, item) => sum + 1, 0);
                const totalValue = this.allItems.reduce((sum, item) => sum + ((item.Value || 0) * (item.StackSize || 1)), 0);
                const vaultCount = new Set(this.allItems.map(item => item.StorageVault)).size;

                document.getElementById('totalItems').textContent = totalItems.toLocaleString();
                document.getElementById('totalValue').textContent = totalValue.toLocaleString() + 'g';
                document.getElementById('vaultCount').textContent = vaultCount;

                document.getElementById('inventoryStats').style.display = 'grid';
                document.getElementById('inventorySearchBar').style.display = 'block';
            }

            search(query) {
                const lowerQuery = query.toLowerCase();
                this.filteredItems = this.allItems.filter(item => {
                    return (
                        item.Name?.toLowerCase().includes(lowerQuery) ||
                        item.vaultName?.toLowerCase().includes(lowerQuery) ||
                        item.details?.Name?.toLowerCase().includes(lowerQuery)
                    );
                });
                this.render();
            }

            render() {
                const container = document.getElementById('inventoryList');

                if (this.filteredItems.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">üéí</div>
                            <h3>No items found</h3>
                            <p>Try adjusting your search or load items data.</p>
                        </div>
                    `;
                    return;
                }

                // Group items by StorageVault
                const groupedItems = this.groupByVault(this.filteredItems);

                // Render accordions for each vault
                container.innerHTML = Object.entries(groupedItems)
                    .sort(([a], [b]) => a.localeCompare(b))
                    .map(([vault, items]) => this.renderVaultAccordion(vault, items))
                    .join('');

                // Add click handlers for accordions
                this.attachAccordionHandlers();
            }

            groupByVault(items) {
                const grouped = {};
                for (const item of items) {
                    const vault = item.vaultName || 'Unknown Vault';
                    if (!grouped[vault]) {
                        grouped[vault] = [];
                    }
                    grouped[vault].push(item);
                }
                return grouped;
            }

            renderVaultAccordion(vault, items) {
                const accordionId = `vault-${vault.replace(/\s+/g, '-').toLowerCase()}`;
                const totalValue = items.reduce((sum, item) => sum + ((item.Value || 0) * (item.StackSize || 1)), 0);
                const totalCount = items.reduce((sum, item) => sum + 1, 0);

                // Sort items by total value (descending)
                const sortedItems = [...items].sort((a, b) => {
                    const aTotal = (a.Value || 0) * (a.StackSize || 1);
                    const bTotal = (b.Value || 0) * (b.StackSize || 1);
                    return bTotal - aTotal;
                });

                return `
                    <div class="location-accordion">
                        <div class="accordion-header" data-accordion="${accordionId}">
                            <div class="accordion-title">
                                <span>üóÑÔ∏è ${vault}</span>
                                <span class="quest-count-badge">${totalCount} items</span>
                            </div>
                            <div class="accordion-icon">‚ñº</div>
                        </div>
                        <div id="${accordionId}" class="accordion-content">
                            <div class="accordion-quests">
                                ${sortedItems.map(item => this.renderItemCard(item)).join('')}
                                <div class="vault-summary">
                                    <span class="vault-summary-label">Total Value:</span>
                                    <span class="vault-summary-value">üí∞ ${totalValue.toLocaleString()}g</span>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }

            renderItemCard(item) {
                const perItemValue = item.Value || 0;
                const totalValue = perItemValue * (item.StackSize || 1);

                // Determine rarity class
                const rarity = item.Rarity || '';
                const rarityClass = rarity ? `rarity-${rarity.toLowerCase()}` : '';

                // Build details badges
                const detailBadges = [];

                if (rarity) {
                    detailBadges.push(`<span class="item-detail-badge">${rarity}</span>`);
                }

                if (item.RequiredLevel || item.Level) {
                    const level = item.RequiredLevel || item.Level;
                    detailBadges.push(`<span class="item-detail-badge">Lvl ${level}</span>`);
                }

                if (item.EquipSlot || item.Slot) {
                    const slot = item.EquipSlot || item.Slot;
                    detailBadges.push(`<span class="item-detail-badge">${slot}</span>`);
                }

                return `
                    <div class="item-card ${rarityClass}">
                        <div class="item-header">
                            <div class="item-name">${item.Name || 'Unknown Item'}</div>
                            ${item.StackSize > 1 ? `<span class="item-stack">√ó${item.StackSize}</span>` : ''}
                        </div>
                        <div class="item-value">
                            üí∞ ${totalValue.toLocaleString()}g
                            ${item.StackSize > 1 ? ` (${perItemValue.toFixed(1)}g each)` : ''}
                        </div>
                        ${detailBadges.length > 0 ? `
                            <div class="item-details">
                                ${detailBadges.join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            attachAccordionHandlers() {
                const container = document.getElementById('inventoryList');
                const headers = container.querySelectorAll('.accordion-header');
                headers.forEach(header => {
                    header.addEventListener('click', () => {
                        const accordionId = header.getAttribute('data-accordion');
                        const content = document.getElementById(accordionId);

                        // Toggle active state
                        header.classList.toggle('active');
                        content.classList.toggle('active');
                    });
                });
            }
        }

        // Parse "Kaeus" ‚Üí {charName:"Kaeus", server:"", key:"Kaeus"}
        // Parse "Kaeus_Server" ‚Üí {charName:"Kaeus", server:"Server", key:"Kaeus:Server"}
        function parseCharacterBaseName(baseName) {
            const idx = baseName.indexOf('_');
            if (idx === -1) return { charName: baseName, server: '', key: baseName };
            return {
                charName: baseName.slice(0, idx),
                server: baseName.slice(idx + 1),
                key: baseName.slice(0, idx) + ':' + baseName.slice(idx + 1)
            };
        }

        function getVendorDataKey() {
            return currentCharacterKey ? 'gorgon-vendor-data:' + currentCharacterKey : 'gorgon-vendor-data';
        }

        function loadVendorData() {
            try { return JSON.parse(localStorage.getItem(getVendorDataKey()) || '{}'); }
            catch { return {}; }
        }

        function saveVendorData(data) {
            localStorage.setItem(getVendorDataKey(), JSON.stringify(data));
        }

        function getStarredVendorsKey() {
            return currentCharacterKey ? 'gorgon-starred-vendors:' + currentCharacterKey : 'gorgon-starred-vendors';
        }

        function loadStarredVendors() {
            try { return new Set(JSON.parse(localStorage.getItem(getStarredVendorsKey()) || '[]')); }
            catch { return new Set(); }
        }

        function saveStarredVendors(set) {
            localStorage.setItem(getStarredVendorsKey(), JSON.stringify([...set]));
        }

        // Regions to pin to the top of the Stores list (in order), rest sort alphabetically
        const STORE_PINNED_REGIONS = ['Serbule', 'Red Wing Casino', 'Eltibule', 'Serbule Hills'];

        // Store Browser
        class StoreBrowser {
            constructor(dataLoader) {
                this.dataLoader = dataLoader;
                this.storeNPCs = [];
                this.vendorData = loadVendorData();
                this.starredVendors = loadStarredVendors();
                this.resetTicker = null;

                // Canonical favor level ordering (low ‚Üí high)
                this.FAVOR_ORDER = [
                    'Despised', 'Disliked', 'Neutral', 'Comfortable',
                    'Friends', 'CloseFriends', 'BestFriends', 'LikeFamily', 'SoulMates'
                ];
            }

            initialize() {
                if (!this.dataLoader.npcsData) return;

                this.storeNPCs = [];
                this.vendorData = loadVendorData();
                this.starredVendors = loadStarredVendors();

                for (const [key, npc] of Object.entries(this.dataLoader.npcsData)) {
                    if (!npc.Services || !Array.isArray(npc.Services)) continue;

                    const storeService = npc.Services.find(s => s.Type === 'Store');
                    if (!storeService) continue;
                    if (!storeService.CapIncreases || storeService.CapIncreases.length === 0) continue;

                    // Skip vendors with no buy categories (entries only have level:value, not level:value:types)
                    const hasBuyTypes = storeService.CapIncreases.some(line => (line.match(/:/g) || []).length >= 2);
                    // if (!hasBuyTypes) continue;

                    // Match character favor level ‚Äî character stores NPC keys like "NPC_CharlesThompson"
                    const charNPC = this.dataLoader.characterData?.NPCs?.[key];
                    const favorLevel = charNPC?.FavorLevel || null;

                    this.storeNPCs.push({
                        key,
                        npc,
                        storeService,
                        favorLevel,
                        area: npc.AreaFriendlyName || npc.AreaName || 'Unknown Region'
                    });
                }

                this.render();
            }

            render() {
                const container = document.getElementById('storeList');

                if (this.storeNPCs.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">üõí</div>
                            <h3>No store data loaded</h3>
                            <p>Load character data to see merchant stores.</p>
                        </div>
                    `;
                    return;
                }

                // Group by region
                const byRegion = {};
                for (const entry of this.storeNPCs) {
                    const region = entry.area;
                    if (!byRegion[region]) byRegion[region] = [];
                    byRegion[region].push(entry);
                }

                const vendorsHtml = Object.entries(byRegion)
                    .sort(([a], [b]) => {
                        const aPin = STORE_PINNED_REGIONS.indexOf(a);
                        const bPin = STORE_PINNED_REGIONS.indexOf(b);
                        if (aPin !== -1 && bPin !== -1) return aPin - bPin;
                        if (aPin !== -1) return -1;
                        if (bPin !== -1) return 1;
                        return a.localeCompare(b);
                    })
                    .map(([region, npcs]) => this.renderRegionAccordion(region, npcs))
                    .join('');

                container.innerHTML = this.renderFavoritesSection() + vendorsHtml + this.renderUnknownVendors() + this.renderNonVendors();

                this.attachHandlers();
                this.startResetTicker();
            }

            renderFavoritesSection() {
                const starred = this.storeNPCs.filter(e => this.starredVendors.has(e.key));
                if (starred.length === 0) return '';

                starred.sort((a, b) => {
                    const regionCmp = a.area.localeCompare(b.area);
                    if (regionCmp !== 0) return regionCmp;
                    return (a.npc.Name || a.key).localeCompare(b.npc.Name || b.key);
                });

                const accordionId = 'store-region-favorites';
                const rows = starred.map(entry => {
                    const { key, npc, storeService, favorLevel, area } = entry;
                    const name = npc.Name || key;
                    const parsedCaps = this.parseCaps(storeService).filter(p => p.favorLevel !== 'Despised');
                    const currentCap = favorLevel ? parsedCaps.find(p => p.favorLevel === favorLevel) : null;
                    const capClass = currentCap ? '' : 'no-cap';
                    const friendsIdx = this.FAVOR_ORDER.indexOf('Friends');
                    const refCap = parsedCaps.find(p => this.FAVOR_ORDER.indexOf(p.favorLevel) >= friendsIdx) || parsedCaps[0];
                    const buysText = refCap ? refCap.buyTypes.join(', ') : '';
                    const favorBadgeHtml = favorLevel
                        ? `<span class="favor-badge favor-${favorLevel.toLowerCase()}">${favorLevel}</span>`
                        : `<span class="favor-badge favor-unknown">Not Met</span>`;
                    const tracked = this.vendorData[key] || {};
                    const remaining = tracked.remaining !== undefined ? tracked.remaining : null;
                    const resetAt = tracked.resetAt || null;
                    let capHtml;
                    if (currentCap) {
                        if (remaining !== null) {
                            const pct = remaining / currentCap.cap;
                            const cls = pct > 0.5 ? 'remaining-high' : pct > 0.2 ? 'remaining-med' : 'remaining-low';
                            capHtml = `<span class="${cls}">${remaining.toLocaleString()}g</span> / ${currentCap.cap.toLocaleString()}g`;
                        } else {
                            capHtml = `üí∞ ${currentCap.cap.toLocaleString()}g`;
                        }
                    } else {
                        capHtml = remaining != null ? `<span class="remaining-unknown">${remaining.toLocaleString()}g / Unknown Cap</span>` : '‚Äî';
                    }
                    let resetHtml = '', resetColClass = 'col-reset';
                    if (resetAt) {
                        const ms = resetAt - Date.now();
                        if (ms <= 0) { resetHtml = 'Ready'; resetColClass += ' reset-ready'; }
                        else resetHtml = this.formatTimeRemaining(ms);
                    }
                    return `
                        <tr data-npc-key="${key}">
                            <td class="col-star"><button class="star-btn starred" title="Remove from favorites">‚òÖ</button></td>
                            <td class="col-name"><a href="https://wiki.projectgorgon.com/wiki/?search=${encodeURIComponent(name)}" target="_blank" rel="noopener noreferrer" style="color: inherit; text-decoration: none;" onmouseover="this.style.color='#667eea';this.style.textDecoration='underline'" onmouseout="this.style.color='inherit';this.style.textDecoration='none'">${name}</a></td>
                            <td class="col-region">${area}</td>
                            <td class="col-favor">${favorBadgeHtml}</td>
                            <td class="col-cap ${capClass}">${capHtml}</td>
                            <td class="${resetColClass}">${resetHtml}</td>
                            <td class="col-buys">${buysText}</td>
                            <td class="col-actions">
                                <div style="display:flex;gap:4px;justify-content:flex-end;align-items:center;">
                                    <div class="tooltip-container">
                                        <button class="tooltip-btn">?</button>
                                        <div class="tooltip-content">
                                            <div class="tooltip-title">All Favor Tiers</div>
                                            ${this.renderCapTable(parsedCaps, favorLevel)}
                                            ${npc.Preferences && npc.Preferences.length > 0 ? `
                                                <div class="tooltip-title tooltip-title-divider">Gift Preferences</div>
                                                ${this.renderPreferencesTable(npc.Preferences)}
                                            ` : ''}
                                        </div>
                                    </div>
                                </div>
                            </td>
                        </tr>
                    `;
                }).join('');

                return `
                    <div id="favorites-section" class="location-accordion">
                        <div class="accordion-header" data-accordion="${accordionId}">
                            <div class="accordion-title">
                                <span>‚≠ê Favorites</span>
                                <span class="quest-count-badge">${starred.length} vendor${starred.length !== 1 ? 's' : ''}</span>
                            </div>
                            <div class="accordion-icon">‚ñº</div>
                        </div>
                        <div id="${accordionId}" class="accordion-content">
                            <div class="stores-region-npcs">
                                <table class="store-table">
                                    <thead>
                                        <tr>
                                            <th class="col-star-header"></th>
                                            <th>Merchant</th>
                                            <th>Region</th>
                                            <th>Favor</th>
                                            <th>Cap</th>
                                            <th>Resets</th>
                                            <th>Buys</th>
                                            <th></th>
                                        </tr>
                                    </thead>
                                    <tbody>${rows}</tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                `;
            }

            renderRegionAccordion(region, npcs) {
                const accordionId = `store-region-${region.replace(/\W+/g, '-').toLowerCase()}`;
                // Sort: starred first (alphabetically), then rest alphabetically
                const sorted = [...npcs].sort((a, b) => {
                    const aStarred = this.starredVendors.has(a.key);
                    const bStarred = this.starredVendors.has(b.key);
                    if (aStarred !== bStarred) return aStarred ? -1 : 1;
                    return (a.npc.Name || a.key).localeCompare(b.npc.Name || b.key);
                });

                return `
                    <div class="location-accordion">
                        <div class="accordion-header" data-accordion="${accordionId}">
                            <div class="accordion-title">
                                <span>üìç ${region}</span>
                                <span class="quest-count-badge">${npcs.length} merchant${npcs.length !== 1 ? 's' : ''}</span>
                            </div>
                            <div class="accordion-icon">‚ñº</div>
                        </div>
                        <div id="${accordionId}" class="accordion-content">
                            <div class="stores-region-npcs">
                                <table class="store-table">
                                    <thead>
                                        <tr>
                                            <th class="col-star-header"></th>
                                            <th>Merchant</th>
                                            <th>Favor</th>
                                            <th>Cap</th>
                                            <th>Resets</th>
                                            <th>Buys</th>
                                            <th></th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${sorted.map(entry => this.renderNPCCard(entry)).join('')}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                `;
            }

            formatTimeRemaining(ms) {
                if (ms <= 0) return 'Ready';
                const s = Math.floor(ms / 1000);
                const d = Math.floor(s / 86400);
                const h = Math.floor((s % 86400) / 3600);
                const m = Math.floor((s % 3600) / 60);
                const parts = [];
                if (d > 0) parts.push(`${d}d`);
                if (h > 0) parts.push(`${h}h`);
                if (m > 0 || parts.length === 0) parts.push(`${m}m`);
                return parts.join(' ');
            }

            updateRowCells(row, key) {
                const tracked = this.vendorData[key] || {};
                const remaining = tracked.remaining !== undefined ? tracked.remaining : null;
                const resetAt = tracked.resetAt || null;

                const entry = this.storeNPCs.find(e => e.key === key);
                const capCell = row.querySelector('.col-cap');

                if (!entry) {
                    // Unknown vendor ‚Äî use cap stored in vendorData
                    if (capCell) {
                        const cap = tracked.cap != null ? tracked.cap : null;
                        if (cap != null) {
                            if (remaining !== null) {
                                const pct = remaining / cap;
                                const cls = pct > 0.5 ? 'remaining-high' : pct > 0.2 ? 'remaining-med' : 'remaining-low';
                                capCell.innerHTML = `<span class="${cls}">${remaining.toLocaleString()}g</span> / ${cap.toLocaleString()}g`;
                            } else {
                                capCell.innerHTML = `üí∞ ${cap.toLocaleString()}g`;
                            }
                        } else {
                            capCell.innerHTML = remaining !== null ? `${remaining.toLocaleString()}g / Unknown Cap` : '‚Äî';
                        }
                    }
                } else {
                    const parsedCaps = this.parseCaps(entry.storeService).filter(p => p.favorLevel !== 'Despised');
                    const currentCap = entry.favorLevel ? parsedCaps.find(p => p.favorLevel === entry.favorLevel) : null;
                    if (currentCap && capCell) {
                        if (remaining !== null) {
                            const pct = remaining / currentCap.cap;
                            const cls = pct > 0.5 ? 'remaining-high' : pct > 0.2 ? 'remaining-med' : 'remaining-low';
                            capCell.innerHTML = `<span class="${cls}">${remaining.toLocaleString()}g</span> / ${currentCap.cap.toLocaleString()}g`;
                        } else {
                            capCell.innerHTML = `üí∞ ${currentCap.cap.toLocaleString()}g`;
                        }
                        capCell.className = 'col-cap';
                    }
                }

                const resetCell = row.querySelector('.col-reset');
                if (resetAt) {
                    const ms = resetAt - Date.now();
                    if (ms <= 0) {
                        resetCell.textContent = 'Ready';
                        resetCell.className = 'col-reset reset-ready';
                    } else {
                        resetCell.textContent = this.formatTimeRemaining(ms);
                        resetCell.className = 'col-reset';
                    }
                } else {
                    resetCell.textContent = '';
                    resetCell.className = 'col-reset';
                }
            }

            startResetTicker() {
                if (this.resetTicker) clearInterval(this.resetTicker);
                this.resetTicker = setInterval(() => {
                    const container = document.getElementById('storeList');
                    if (!container) return;
                    container.querySelectorAll('tr[data-npc-key]').forEach(row => {
                        const key = row.getAttribute('data-npc-key');
                        const tracked = this.vendorData[key];
                        if (!tracked?.resetAt) return;
                        const resetCell = row.querySelector('.col-reset');
                        if (!resetCell) return;
                        const ms = tracked.resetAt - Date.now();
                        if (ms <= 0) {
                            resetCell.textContent = 'Ready';
                            resetCell.className = 'col-reset reset-ready';
                        } else {
                            resetCell.textContent = this.formatTimeRemaining(ms);
                            resetCell.className = 'col-reset';
                        }
                    });
                }, 30000);
            }

            findNPCKeyByInternalKey(internalKey) {
                if (!internalKey) return null;
                // Direct key match ‚Äî most reliable, no CDN field guessing needed
                return this.storeNPCs.some(en => en.key === internalKey) ? internalKey : null;
            }

            findNPCKeyById(npcId) {
                if (npcId == null) return null;
                const id = Number(npcId);
                // CDN npc objects may use various field names for their numeric ID
                const found = this.storeNPCs.find(en =>
                    en.npc.ID === id || en.npc.NPCID === id || en.npc.NpcId === id
                );
                return found ? found.key : null;
            }

            findNPCKeyByDescription(desc) {
                if (!desc) return null;
                // Match against the vendor's store service description
                const found = this.storeNPCs.find(en =>
                    (en.storeService?.ServiceDescription === desc) ||
                    (en.npc.Services || []).some(s =>
                        s.ServiceDescription === desc || s.Description === desc
                    )
                );
                return found ? found.key : null;
            }

            findNPCKeyByName(displayName) {
                if (!displayName) return null;
                const lower = displayName.toLowerCase();
                let found = this.storeNPCs.find(en => en.npc.Name === displayName);
                if (found) return found.key;
                found = this.storeNPCs.find(en => (en.npc.Name || '').toLowerCase() === lower);
                return found ? found.key : null;
            }

            applyVendorCaptures(captures) {

                let updated = false;
                for (const capture of Object.values(captures)) {
                    // Try matching strategies in priority order
                    const key =
                        this.findNPCKeyByInternalKey(capture.npcInternalKey) ||
                        this.findNPCKeyById(capture.npcId) ||
                        this.findNPCKeyByDescription(capture.description) ||
                        this.findNPCKeyByName(capture.vendorName);
                    if (!key) {
                        // No CDN match ‚Äî store under synthetic key for display in unknown vendors section
                        const syntheticKey = capture.npcInternalKey || `npc:${capture.npcId}`;
                        const existing = this.vendorData[syntheticKey] || {};
                        const capAt = capture.capturedAt || 0;
                        if (capAt <= (existing.capturedAt || 0)) continue;
                        this.vendorData[syntheticKey] = {
                            ...existing,
                            isUnknown: true,
                            vendorName: capture.vendorName || existing.vendorName || `NPC#${capture.npcId}`,
                            cap: capture.cap != null ? capture.cap : existing.cap,
                            favorLevel: capture.favorLevel || existing.favorLevel,
                            remaining: capture.remaining != null ? Math.round(capture.remaining) : existing.remaining,
                            capturedAt: capAt,
                            npcId: capture.npcId,
                        };
                        if (capture.resetAt) {
                            this.vendorData[syntheticKey].resetAt = capture.resetAt;
                        }
                        updated = true;
                        this.refreshUnknownVendorsSection();
                        const label = capture.vendorName || `NPC#${capture.npcId}`;
                        const remStr = capture.remaining != null ? `${Math.round(capture.remaining)}g` : '?';
                        showCaptureToast(`Auto-filled (new): ${label} ‚Äî ${remStr} remaining`);
                        continue;
                    }

                    const existing = this.vendorData[key] || {};
                    const capAt = capture.capturedAt || 0;
                    if (capAt <= (existing.capturedAt || 0)) continue;

                    this.vendorData[key] = {
                        ...existing,
                        remaining: capture.remaining != null ? Math.round(capture.remaining) : existing.remaining,
                        capturedAt: capAt,
                    };
                    if (capture.resetAt) {
                        this.vendorData[key].resetAt = capture.resetAt;
                    }

                    document.querySelectorAll(`#storeList tr[data-npc-key="${key}"]`).forEach(r => this.updateRowCells(r, key));
                    updated = true;

                    const label = capture.vendorName || `NPC#${capture.npcId} (${key})`;
                    const remStr = capture.remaining != null ? `${Math.round(capture.remaining)}g` : '?';
                    showCaptureToast(`Auto-filled: ${label} ‚Äî ${remStr} remaining`);
                }

                if (updated) saveVendorData(this.vendorData);
            }

            parseCaps(storeService) {
                return (storeService.CapIncreases || []).map(line => {
                    const colonIdx = line.indexOf(':');
                    const secondColonIdx = line.indexOf(':', colonIdx + 1);
                    const fLevel = line.substring(0, colonIdx);
                    const cap = (secondColonIdx >= 0 ? parseInt(line.substring(colonIdx + 1, secondColonIdx)) : parseInt(line.substring(colonIdx + 1))) || 0;
                    const buyTypes = secondColonIdx >= 0 ? line.substring(secondColonIdx + 1).split(',') : ['Any'];
                    return { favorLevel: fLevel, cap, buyTypes };
                });
            }

            renderNPCCard(entry) {
                const { key, npc, storeService, favorLevel } = entry;
                const name = npc.Name || key;

                const parsedCaps = this.parseCaps(storeService).filter(p => p.favorLevel !== 'Despised');
                const currentCap = favorLevel ? parsedCaps.find(p => p.favorLevel === favorLevel) : null;
                const capClass = currentCap ? '' : 'no-cap';

                const friendsIdx = this.FAVOR_ORDER.indexOf('Friends');
                const refCap = parsedCaps.find(p => this.FAVOR_ORDER.indexOf(p.favorLevel) >= friendsIdx) || parsedCaps[0];
                const buysText = refCap ? refCap.buyTypes.join(', ') : '';

                const favorBadgeHtml = favorLevel
                    ? `<span class="favor-badge favor-${favorLevel.toLowerCase()}">${favorLevel}</span>`
                    : `<span class="favor-badge favor-unknown">Not Met</span>`;

                // Tracker data from localStorage
                const tracked = this.vendorData[key] || {};
                const remaining = tracked.remaining !== undefined ? tracked.remaining : null;
                const resetAt = tracked.resetAt || null;

                // Cap cell
                let capHtml;
                if (currentCap) {
                    if (remaining !== null) {
                        const pct = remaining / currentCap.cap;
                        const cls = pct > 0.5 ? 'remaining-high' : pct > 0.2 ? 'remaining-med' : 'remaining-low';
                        capHtml = `<span class="${cls}">${remaining.toLocaleString()}g</span> / ${currentCap.cap.toLocaleString()}g`;
                    } else {
                        capHtml = `üí∞ ${currentCap.cap.toLocaleString()}g`;
                    }
                } else {
                    if (remaining != null) {
                        capHtml = `<span class="remaining-unknown">${remaining.toLocaleString()}g / ${currentCap ? currentCap.toLocaleString() + 'g' : 'Unknown Cap'}</span>`;
                    } else {
                        capHtml = '‚Äî';
                    }
                }

                // Reset cell
                let resetHtml = '', resetColClass = 'col-reset';
                if (resetAt) {
                    const ms = resetAt - Date.now();
                    if (ms <= 0) { resetHtml = 'Ready'; resetColClass += ' reset-ready'; }
                    else resetHtml = this.formatTimeRemaining(ms);
                }

                const isStarred = this.starredVendors.has(key);
                return `
                    <tr data-npc-key="${key}">
                        <td class="col-star"><button class="star-btn${isStarred ? ' starred' : ''}" title="Pin to top of region">‚òÖ</button></td>
                        <td class="col-name"><a href="https://wiki.projectgorgon.com/wiki/?search=${encodeURIComponent(name)}" target="_blank" rel="noopener noreferrer" style="color: inherit; text-decoration: none;" onmouseover="this.style.color='#667eea';this.style.textDecoration='underline'" onmouseout="this.style.color='inherit';this.style.textDecoration='none'">${name}</a></td>
                        <td class="col-favor">${favorBadgeHtml}</td>
                        <td class="col-cap ${capClass}">${capHtml}</td>
                        <td class="${resetColClass}">${resetHtml}</td>
                        <td class="col-buys">${buysText}</td>
                        <td class="col-actions">
                            <div style="display:flex;gap:4px;justify-content:flex-end;align-items:center;">
                                <div class="tooltip-container">
                                    <button class="tooltip-btn">?</button>
                                    <div class="tooltip-content">
                                        <div class="tooltip-title">All Favor Tiers</div>
                                        ${this.renderCapTable(parsedCaps, favorLevel)}
                                        ${npc.Preferences && npc.Preferences.length > 0 ? `
                                            <div class="tooltip-title tooltip-title-divider">Gift Preferences</div>
                                            ${this.renderPreferencesTable(npc.Preferences)}
                                        ` : ''}
                                    </div>
                                </div>
                            </div>
                        </td>
                    </tr>
                `;
            }

            renderCapTable(parsedCaps, currentFavorLevel) {
                if (parsedCaps.length === 0) {
                    return '<p style="padding: 12px; color: #6c757d; font-size: 0.9em;">No cap data available.</p>';
                }

                const currentFavorIndex = this.FAVOR_ORDER.indexOf(currentFavorLevel);

                const rows = parsedCaps.map(cap => {
                    const capFavorIndex = this.FAVOR_ORDER.indexOf(cap.favorLevel);
                    let rowClass = '';
                    if (currentFavorLevel) {
                        if (cap.favorLevel === currentFavorLevel) {
                            rowClass = 'cap-row-current';
                        } else if (capFavorIndex < currentFavorIndex) {
                            rowClass = 'cap-row-unlocked';
                        } else {
                            rowClass = 'cap-row-locked';
                        }
                    }
                    return `
                        <tr class="${rowClass}">
                            <td>${cap.favorLevel}</td>
                            <td>${cap.cap.toLocaleString()}g</td>
                        </tr>
                    `;
                }).join('');

                return `
                    <table class="cap-table">
                        <thead>
                            <tr>
                                <th>Favor Level</th>
                                <th>Money Cap</th>
                            </tr>
                        </thead>
                        <tbody>${rows}</tbody>
                    </table>
                `;
            }

            renderPreferencesTable(preferences) {
                // Sort by Pref descending so highest favor-per-gift items appear first
                const sorted = [...preferences].sort((a, b) => (b.Pref || 0) - (a.Pref || 0));

                const rows = sorted.map(pref => {
                    const desire = pref.Desire || '';
                    const desireStyle = desire === 'Love'
                        ? 'color: #155724; font-weight: 600;'
                        : desire === 'Hate' ? 'color: #721c24; font-weight: 600;' : '';
                    return `
                        <tr>
                            <td>${pref.Name || ''}</td>
                            <td style="${desireStyle}">${desire}</td>
                            <td>${pref.Pref !== undefined ? pref.Pref : ''}</td>
                        </tr>
                    `;
                }).join('');

                return `
                    <table class="cap-table">
                        <thead>
                            <tr>
                                <th>Gift</th>
                                <th>Desire</th>
                                <th>Favor/Gift</th>
                            </tr>
                        </thead>
                        <tbody>${rows}</tbody>
                    </table>
                `;
            }

            renderNonVendors() {
                const charNPCs = this.dataLoader.characterData?.NPCs;
                if (!charNPCs) return '';

                const vendorKeys = new Set(this.storeNPCs.map(e => e.key));
                const nonVendors = [];

                for (const [key, charNPC] of Object.entries(charNPCs)) {
                    if (vendorKeys.has(key)) continue;
                    const npcData = this.dataLoader.npcsData?.[key];
                    const name = npcData?.Name || key;
                    const favorLevel = charNPC.FavorLevel || 'Unknown';
                    nonVendors.push({ name, favorLevel });
                }

                if (nonVendors.length === 0) return '';

                nonVendors.sort((a, b) => a.name.localeCompare(b.name));

                const accordionId = 'store-region-non-vendors';
                const rows = nonVendors.map(nv => `
                    <tr>
                        <td class="col-name">${nv.name}</td>
                        <td class="col-favor"><span class="favor-badge favor-${nv.favorLevel.toLowerCase()}">${nv.favorLevel}</span></td>
                    </tr>
                `).join('');

                return `
                    <div class="location-accordion" style="margin-top: 16px;">
                        <div class="accordion-header" data-accordion="${accordionId}">
                            <div class="accordion-title">
                                <span>üë§ Non-Vendors</span>
                                <span class="quest-count-badge">${nonVendors.length} NPC${nonVendors.length !== 1 ? 's' : ''}</span>
                            </div>
                            <div class="accordion-icon">‚ñº</div>
                        </div>
                        <div id="${accordionId}" class="accordion-content">
                            <div class="stores-region-npcs">
                                <table class="store-table">
                                    <thead>
                                        <tr>
                                            <th>NPC</th>
                                            <th>Favor</th>
                                        </tr>
                                    </thead>
                                    <tbody>${rows}</tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                `;
            }

            renderUnknownVendors() {
                const knownKeys = new Set(this.storeNPCs.map(e => e.key));
                const unknownEntries = Object.entries(this.vendorData)
                    .filter(([k, v]) => v.isUnknown && !knownKeys.has(k));

                if (unknownEntries.length === 0) return '';

                unknownEntries.sort(([, a], [, b]) => (a.vendorName || '').localeCompare(b.vendorName || ''));

                const accordionId = 'store-region-unknown-vendors';
                const rows = unknownEntries.map(([key, tracked]) => {
                    const name = tracked.vendorName || key;
                    const cap = tracked.cap != null ? tracked.cap : null;
                    const remaining = tracked.remaining !== undefined ? tracked.remaining : null;
                    const resetAt = tracked.resetAt || null;
                    const favorLevel = tracked.favorLevel || 'Unknown';

                    let capHtml;
                    if (cap != null) {
                        if (remaining !== null) {
                            const pct = remaining / cap;
                            const cls = pct > 0.5 ? 'remaining-high' : pct > 0.2 ? 'remaining-med' : 'remaining-low';
                            capHtml = `<span class="${cls}">${remaining.toLocaleString()}g</span> / ${cap.toLocaleString()}g`;
                        } else {
                            capHtml = `üí∞ ${cap.toLocaleString()}g`;
                        }
                    } else {
                        capHtml = remaining !== null ? `${remaining.toLocaleString()}g / Unknown Cap` : '‚Äî';
                    }

                    let resetHtml = '', resetColClass = 'col-reset';
                    if (resetAt) {
                        const ms = resetAt - Date.now();
                        if (ms <= 0) { resetHtml = 'Ready'; resetColClass += ' reset-ready'; }
                        else resetHtml = this.formatTimeRemaining(ms);
                    }

                    return `
                        <tr data-npc-key="${key}">
                            <td class="col-name">${name}</td>
                            <td class="col-favor"><span class="favor-badge favor-${favorLevel.toLowerCase()}">${favorLevel}</span></td>
                            <td class="col-cap">${capHtml}</td>
                            <td class="${resetColClass}">${resetHtml}</td>
                        </tr>
                    `;
                }).join('');

                return `
                    <div id="unknown-vendors-section" class="location-accordion" style="margin-top: 16px;">
                        <div class="accordion-header" data-accordion="${accordionId}">
                            <div class="accordion-title">
                                <span>‚ùì Seen In-Game (No CDN Data)</span>
                                <span class="quest-count-badge">${unknownEntries.length} vendor${unknownEntries.length !== 1 ? 's' : ''}</span>
                            </div>
                            <div class="accordion-icon">‚ñº</div>
                        </div>
                        <div id="${accordionId}" class="accordion-content">
                            <div class="stores-region-npcs">
                                <table class="store-table">
                                    <thead>
                                        <tr>
                                            <th>Vendor</th>
                                            <th>Favor</th>
                                            <th>Cap / Remaining</th>
                                            <th>Resets In</th>
                                        </tr>
                                    </thead>
                                    <tbody>${rows}</tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                `;
            }

            refreshUnknownVendorsSection() {
                const container = document.getElementById('storeList');
                if (!container) return;

                const accordionId = 'store-region-unknown-vendors';
                const wasOpen = document.getElementById(accordionId)?.classList.contains('active');

                const html = this.renderUnknownVendors();
                const existing = document.getElementById('unknown-vendors-section');

                if (existing) {
                    if (html) {
                        existing.outerHTML = html;
                    } else {
                        existing.remove();
                        return;
                    }
                } else if (html) {
                    // Insert before the non-vendors section if present, else append
                    const nonVendorEl = container.querySelector('[data-accordion="store-region-non-vendors"]')?.closest('.location-accordion');
                    if (nonVendorEl) {
                        nonVendorEl.insertAdjacentHTML('beforebegin', html);
                    } else {
                        container.insertAdjacentHTML('beforeend', html);
                    }
                } else {
                    return;
                }

                // Restore accordion open state
                const newHeader = container.querySelector(`[data-accordion="${accordionId}"]`);
                const newContent = document.getElementById(accordionId);
                if (newHeader && newContent) {
                    if (wasOpen) {
                        newHeader.classList.add('active');
                        newContent.classList.add('active');
                    }
                    newHeader.addEventListener('click', () => {
                        newHeader.classList.toggle('active');
                        newContent.classList.toggle('active');
                        const state = this.loadAccordionState();
                        state[accordionId] = newContent.classList.contains('active');
                        this.saveAccordionState(state);
                    });
                }

            }

            toggleStarred(key) {
                if (this.starredVendors.has(key)) this.starredVendors.delete(key);
                else this.starredVendors.add(key);
                saveStarredVendors(this.starredVendors);
            }

            loadAccordionState() {
                const key = currentCharacterKey ? 'gorgon-store-accordion:' + currentCharacterKey : 'gorgon-store-accordion';
                try { return JSON.parse(localStorage.getItem(key) || '{}'); }
                catch { return {}; }
            }

            saveAccordionState(state) {
                const key = currentCharacterKey ? 'gorgon-store-accordion:' + currentCharacterKey : 'gorgon-store-accordion';
                localStorage.setItem(key, JSON.stringify(state));
            }

            attachHandlers() {
                const container = document.getElementById('storeList');

                // Restore accordion open/closed state from localStorage
                // 'store-region-favorites' defaults to open unless explicitly closed
                const accordionState = this.loadAccordionState();
                container.querySelectorAll('.accordion-header').forEach(header => {
                    const id = header.getAttribute('data-accordion');
                    const content = document.getElementById(id);
                    if (!content) return;
                    const defaultOpen = id === 'store-region-favorites';
                    const shouldOpen = defaultOpen ? accordionState[id] !== false : accordionState[id] === true;
                    if (shouldOpen) {
                        header.classList.add('active');
                        content.classList.add('active');
                    }
                });

                // Region accordion headers
                container.querySelectorAll('.accordion-header').forEach(header => {
                    header.addEventListener('click', () => {
                        const id = header.getAttribute('data-accordion');
                        const content = document.getElementById(id);
                        header.classList.toggle('active');
                        content.classList.toggle('active');
                        // Persist state
                        const state = this.loadAccordionState();
                        state[id] = content.classList.contains('active');
                        this.saveAccordionState(state);
                    });
                });

                // Star/pin buttons ‚Äî full re-render so favorites section and region order stay correct
                container.querySelectorAll('.star-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const key = btn.closest('tr').getAttribute('data-npc-key');
                        this.toggleStarred(key);
                        this.render();
                    });
                });

                // Tooltip toggle buttons
                container.querySelectorAll('.tooltip-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const tooltipContainer = btn.closest('.tooltip-container');
                        const isOpen = tooltipContainer.classList.toggle('tooltip-open');
                        btn.classList.toggle('tooltip-active', isOpen);
                    });
                });

                // Close open tooltips when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.tooltip-container')) {
                        container.querySelectorAll('.tooltip-container.tooltip-open').forEach(tc => {
                            tc.classList.remove('tooltip-open');
                            tc.querySelector('.tooltip-btn')?.classList.remove('tooltip-active');
                        });
                    }
                }, { capture: false });

            }
        }

        // Show a brief non-blocking toast when vendor captures auto-fill data
        function showCaptureToast(message) {
            const toast = document.getElementById('captureToast');
            if (!toast) return;
            toast.textContent = message;
            toast.style.display = 'block';
            clearTimeout(toast._hideTimer);
            toast._hideTimer = setTimeout(() => { toast.style.display = 'none'; }, 4000);
        }

        // ‚îÄ‚îÄ Player.log Watcher ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        let playerLogFileHandle = null;
        let playerLogOffset = 0;
        let playerLogPollTimer = null;

        // Reports folder auto-watcher
        let reportsWatchTimer = null;
        let lastLoadedMtime = 0;
        let isLoadingData = false;

        async function pollReportsFolder() {
            if (!reportsDirectoryHandle || isLoadingData) return;
            try {
                const reportsDir = await dataLoader.resolveReportsDir(reportsDirectoryHandle);
                let maxMtime = 0;
                for await (const [name, handle] of reportsDir.entries()) {
                    if (handle.kind !== 'file' || !name.endsWith('.json')) continue;
                    if (!name.startsWith('Character_') && !name.includes('_items_')) continue;
                    const f = await handle.getFile();
                    if (f.lastModified > maxMtime) maxMtime = f.lastModified;
                }
                if (maxMtime > lastLoadedMtime && lastLoadedMtime > 0) {
                    console.log('[reports watcher] Change detected ‚Äî reloading...');
                    await loadAllDataFromDirectory(reportsDirectoryHandle);
                }
            } catch (e) {
                console.warn('[reports watcher] poll error:', e);
            }
        }

        function startReportsWatcher() {
            if (reportsWatchTimer) clearInterval(reportsWatchTimer);
            reportsWatchTimer = setInterval(pollReportsFolder, 10000);
        }

        function updateReportsWatchStatus(active) {
            const el = document.getElementById('reportsWatchStatus');
            if (!el) return;
            if (active) {
                el.textContent = '‚óè Auto-watching';
                el.style.color = '#28a745';
            } else {
                el.textContent = '';
            }
        }

        async function savePlayerLogHandle(handle) {
            try {
                const db = await openHandlesDB();
                const tx = db.transaction('handles', 'readwrite');
                tx.objectStore('handles').put(handle, 'playerLogFile');
                await new Promise(resolve => { tx.oncomplete = resolve; });
            } catch (e) { /* non-critical */ }
        }

        async function getSavedPlayerLogHandle() {
            try {
                const db = await openHandlesDB();
                return await new Promise(resolve => {
                    const req = db.transaction('handles', 'readonly').objectStore('handles').get('playerLogFile');
                    req.onsuccess = (e) => resolve(e.target.result || null);
                    req.onerror = () => resolve(null);
                });
            } catch (e) { return null; }
        }

        // Maps numeric npcId ‚Üí internal key e.g. 12485 ‚Üí "NPC_Ragabir"
        // Populated by ProcessStartInteraction lines that precede vendor screen opens.
        const npcIdToKeyMap = {};

        const RE_LOGIN             = /Logged in as character (\w+)/;
        const RE_START_INTERACTION = /LocalPlayer: ProcessStartInteraction\((\d+),.*?"([^"]+)"\)/;
        const RE_VENDOR_SCREEN     = /LocalPlayer: ProcessVendorScreen\((\d+), (\w+), (\d+), (\d+), (\d+), "([^"]*)"/;
        const RE_TALK_SCREEN       = /LocalPlayer: ProcessTalkScreen\(\d+, "[^"]*", "(<h1>Shops Selling [^"]+)", "/;

        // Parse the HTML content string from a ProcessTalkScreen "Shops Selling" line.
        // The content uses literal \n / \t escape sequences (two chars each) as it appears on one log line.
        function parseShopsContent(raw) {
            const content = raw.replace(/\\n/g, '\n').replace(/\\t/g, '\t');

            const titleMatch = /<h1>Shops Selling (.+?)<\/h1>/i.exec(content);
            if (!titleMatch) return null;
            const itemName = titleMatch[1].trim();

            const countMatch = /(\d+) shops? have that item for sale/i.exec(content);
            const count = countMatch ? parseInt(countMatch[1]) : null;

            const shopRe = /\[([A-Z]-\d+)\]\s*<em>([^<]+)<\/em>\s*\(run by ([^)]+)\)/g;
            const shops = [];
            let m;
            while ((m = shopRe.exec(content)) !== null) {
                shops.push({ booth: m[1], name: m[2].trim(), owner: m[3].trim() });
            }

            const elseSection = /Also for sale at player shops elsewhere[^:]*:([\s\S]*)$/.exec(content);
            const elsewhere = [];
            if (elseSection) {
                const elseRe = /([^\n:]+): for sale at (\d+) shops?/g;
                let em;
                while ((em = elseRe.exec(elseSection[1])) !== null) {
                    elsewhere.push({ location: em[1].trim(), count: parseInt(em[2]) });
                }
            }

            return { itemName, count, shops, elsewhere };
        }

        function showShopsCard(data) {
            const card = document.getElementById('shopsSellCard');
            if (!card) return;

            const esc = s => String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');

            // Cross-reference with price tracker
            const trackedItems = Object.values(vendorPriceTracker.data.items);
            const matched = trackedItems.filter(item => {
                const a = item.name.toLowerCase(), b = data.itemName.toLowerCase();
                return a === b || a.includes(b) || b.includes(a);
            });

            // Sort booths: letter block (A, B, ‚Ä¶) then by stall number
            const sortedShops = [...data.shops].sort((a, b) => {
                const [aL, aN] = a.booth.split('-');
                const [bL, bN] = b.booth.split('-');
                if (aL !== bL) return aL.localeCompare(bL);
                return parseInt(aN) - parseInt(bN);
            });

            const shopsHtml = sortedShops.length > 0 ? `
                <table class="shops-card-table">
                    <thead><tr><th>Booth</th><th>Shop Name</th><th>Owner</th><th>Price</th></tr></thead>
                    <tbody>${sortedShops.map(s => `
                        <tr>
                            <td>${s.booth}</td>
                            <td>${esc(s.name)}</td>
                            <td>${esc(s.owner)}</td>
                            <td><button class="shops-add-price-btn"
                                    data-item="${esc(data.itemName)}"
                                    data-location="${esc(s.booth)}">+ Add</button></td>
                        </tr>`).join('')}
                    </tbody>
                </table>` : '';

            const elsewhereHtml = data.elsewhere.length > 0 ? `
                <div class="shops-card-elsewhere">
                    Elsewhere: ${data.elsewhere.map(e => `<strong>${esc(e.location)}</strong> (${e.count} shop${e.count !== 1 ? 's' : ''})`).join(', ')}
                </div>` : '';

            let pricesHtml = '';
            if (matched.length > 0) {
                const rows = matched.flatMap(item =>
                    item.entries
                        .filter(e => !e.retired)
                        .map(e => {
                            const ageMs = Date.now() - e.timestamp;
                            const age = vendorPriceTracker.formatAge(ageMs);
                            return `<div class="shops-card-price-row">
                                <span class="shops-card-price-gold">${e.price.toLocaleString()}g</span>
                                ${e.location ? `<span class="shops-card-price-loc">@ ${esc(e.location)}</span>` : ''}
                                <span class="shops-card-price-age">${age} ago</span>
                            </div>`;
                        })
                );
                if (rows.length > 0) {
                    pricesHtml = `
                        <div class="shops-card-prices">
                            <div class="shops-card-prices-title">üìä Your tracked prices for ${esc(data.itemName)}</div>
                            ${rows.join('')}
                        </div>`;
                }
            }

            const countStr = data.count !== null ? ` ¬∑ ${data.count} shop${data.count !== 1 ? 's' : ''}` : '';

            card.className = 'shops-card';
            card.innerHTML = `
                <div class="shops-card-header">
                    <div>
                        <span class="shops-card-title">Shops Selling: ${esc(data.itemName)}</span>
                        <span class="shops-card-subtitle">${countStr}</span>
                    </div>
                    <button class="shops-card-close" id="shopsSellCardClose">‚úï</button>
                </div>
                <div class="shops-card-body">
                    ${shopsHtml}
                    ${elsewhereHtml}
                    ${pricesHtml}
                </div>`;
            card.style.display = 'block';

            document.getElementById('shopsSellCardClose').onclick = () => {
                card.style.display = 'none';
            };

            card.querySelectorAll('.shops-add-price-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    vendorPriceTracker.quickAddEntry(
                        btn.getAttribute('data-item'),
                        btn.getAttribute('data-location')
                    );
                });
            });

            // Bring the Prices tab to focus so the user sees the card
            switchTab('prices');
        }

        async function pollPlayerLog() {
            if (!playerLogFileHandle) return;
            try {
                const file = await playerLogFileHandle.getFile();
                if (file.size > playerLogOffset) {
                    const newBytes = file.size - playerLogOffset;
                    const text = await file.slice(playerLogOffset).text();
                    const lines = text.split('\n');
                    let vendorLinesFound = 0;

                    for (const line of lines) {
                        // Detect character login ‚Üí auto-switch character context
                        const loginMatch = RE_LOGIN.exec(line);
                        if (loginMatch && availableCharacters.length > 0 && reportsDirectoryHandle) {
                            const charName = loginMatch[1];
                            const matchingChar = availableCharacters.find(c => c.charName === charName);
                            if (matchingChar && matchingChar.key !== currentCharacterKey) {
                                console.log(`[player.log] Login detected for "${charName}" ‚Äî switching character context`);
                                const picker = document.getElementById('characterPicker');
                                if (picker) picker.value = matchingChar.key;
                                loadAllDataFromDirectory(reportsDirectoryHandle, matchingChar).catch(console.error);
                            }
                            continue;
                        }

                        // Build the id‚Üíkey map from interaction lines
                        const im = RE_START_INTERACTION.exec(line);
                        if (im) {
                            const [, id, internalKey] = im;
                            npcIdToKeyMap[parseInt(id)] = internalKey;
                            console.log(`[player.log] Mapped NPC#${id} ‚Üí ${internalKey}`);
                            continue;
                        }

                        // Detect "Shops Selling X" talk screen ‚Üí show card in Prices tab
                        const tm = RE_TALK_SCREEN.exec(line);
                        if (tm) {
                            const parsed = parseShopsContent(tm[1]);
                            if (parsed) showShopsCard(parsed);
                            continue;
                        }

                        // Parse vendor screen events
                        const vm = RE_VENDOR_SCREEN.exec(line);
                        if (vm) {
                            const [, npcId, favorLevel, remaining, resetAt, cap, description] = vm;
                            const id = parseInt(npcId);
                            const internalKey = npcIdToKeyMap[id] || null;
                            const capture = {
                                npcId:       id,
                                npcInternalKey: internalKey,
                                favorLevel,
                                remaining:   parseInt(remaining),
                                resetAt:     parseInt(resetAt),
                                cap:         parseInt(cap),
                                description,
                                capturedAt:  Date.now(),
                            };
                            vendorLinesFound++;
                            console.log(
                                `[vendor] NPC#${id} (${internalKey || '?'}) ${favorLevel}` +
                                ` remaining=${capture.remaining} cap=${capture.cap}` +
                                ` resetAt=${new Date(capture.resetAt).toLocaleString()}`,
                                capture
                            );
                            storeBrowser.applyVendorCaptures({ [id]: capture });
                        }
                    }

                    if (vendorLinesFound || newBytes > 0) {
                        console.log(`[player.log] +${newBytes}B, ${lines.length} lines, ${vendorLinesFound} vendor event(s)`);
                    }
                }
                playerLogOffset = file.size;
            } catch (e) {
                console.warn('[player.log] poll error:', e);
            }
        }

        function startPlayerLogWatcher() {
            if (playerLogPollTimer) clearInterval(playerLogPollTimer);
            playerLogPollTimer = setInterval(pollPlayerLog, 2000);
            pollPlayerLog(); // immediate first poll
        }

        function updatePlayerLogStatus(watching) {
            const btn = document.getElementById('selectPlayerLogBtn');
            if (!btn) return;
            if (watching) {
                btn.textContent = '‚óè Player.log';
                btn.classList.add('player-log-active');
            } else {
                btn.textContent = 'üìã Watch Player.log';
                btn.classList.remove('player-log-active');
            }
        }

        async function selectPlayerLogFile() {
            try {
                const pickerOpts = { multiple: false, id: 'gorgon-playerlog' };
                const saved = await getSavedPlayerLogHandle();
                if (saved) pickerOpts.startIn = saved;
                const [handle] = await window.showOpenFilePicker(pickerOpts);
                playerLogFileHandle = handle;
                await savePlayerLogHandle(handle);
                // Start from end of file ‚Äî only capture new events going forward
                playerLogOffset = (await handle.getFile()).size;
                startPlayerLogWatcher();
                updatePlayerLogStatus(true);
            } catch (e) {
                if (e.name !== 'AbortError') alert('Error selecting Player.log: ' + e.message);
            }
        }

        // ‚îÄ‚îÄ Vendor Price Tracker ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        function generateId() {
            return crypto.randomUUID ? crypto.randomUUID()
                : Math.random().toString(36).slice(2) + Date.now().toString(36);
        }

        function loadPriceTrackerData() {
            try { return JSON.parse(localStorage.getItem('gorgon-price-tracker') || '{"items":{}}'); }
            catch { return { items: {} }; }
        }

        function savePriceTrackerData(data) {
            localStorage.setItem('gorgon-price-tracker', JSON.stringify(data));
        }

        class VendorPriceTracker {
            constructor() {
                this.data = loadPriceTrackerData();
                this.searchQuery = '';
                this.expandedItems = new Set();
                this._editingItemId = null;
                this._editingEntryId = null;
            }

            getFilteredItems() {
                const q = this.searchQuery.toLowerCase();
                return Object.values(this.data.items)
                    .filter(item => !q || item.name.toLowerCase().includes(q))
                    .sort((a, b) => a.name.localeCompare(b.name));
            }

            addItem(name) {
                const id = generateId();
                this.data.items[id] = { id, name: name.trim(), entries: [] };
                savePriceTrackerData(this.data);
                this.expandedItems.add(id);
                this.render();
            }

            deleteItem(id) {
                const name = this.data.items[id]?.name || 'this item';
                if (!confirm(`Delete "${name}" and all its price data?`)) return;
                delete this.data.items[id];
                this.expandedItems.delete(id);
                savePriceTrackerData(this.data);
                this.render();
            }

            addEntry(itemId, { location, price, timestamp }) {
                const item = this.data.items[itemId];
                // If a non-retired entry with the same location already exists, update it in place
                const existing = location
                    ? item.entries.find(e => !e.retired && e.location.toLowerCase() === location.toLowerCase())
                    : null;
                if (existing) {
                    existing.price = price;
                    existing.timestamp = timestamp;
                } else {
                    item.entries.unshift({ id: generateId(), location, price, timestamp, retired: false });
                }
                savePriceTrackerData(this.data);
                this.render();
            }

            editEntry(itemId, entryId, { location, price, timestamp }) {
                const entry = this.data.items[itemId].entries.find(e => e.id === entryId);
                if (entry) { entry.location = location; entry.price = price; entry.timestamp = timestamp; }
                savePriceTrackerData(this.data);
                this.render();
            }

            retireEntry(itemId, entryId) {
                const entry = this.data.items[itemId].entries.find(e => e.id === entryId);
                if (entry) entry.retired = !entry.retired;
                savePriceTrackerData(this.data);
                this.render();
            }

            deleteEntry(itemId, entryId) {
                const item = this.data.items[itemId];
                item.entries = item.entries.filter(e => e.id !== entryId);
                savePriceTrackerData(this.data);
                this.render();
            }

            calcStats(entries) {
                const active = entries.filter(e => !e.retired);
                if (!active.length) return { avgPrice: null, avgAgeMs: null, count: 0, totalCount: entries.length };
                const avgPrice = active.reduce((s, e) => s + e.price, 0) / active.length;
                const now = Date.now();
                const avgAgeMs = active.reduce((s, e) => s + (now - e.timestamp), 0) / active.length;
                const lowPrice = Math.min(...active.map(e => e.price));
                return { avgPrice, avgAgeMs, count: active.length, totalCount: entries.length, lowPrice };
            }

            formatAge(ms) {
                if (ms < 0) ms = 0;
                const totalMin = Math.floor(ms / 60000);
                const d = Math.floor(totalMin / 1440);
                const h = Math.floor((totalMin % 1440) / 60);
                const m = totalMin % 60;
                if (d > 0) return h > 0 ? `${d}d ${h}h` : `${d}d`;
                if (h > 0) return m > 0 ? `${h}h ${m}m` : `${h}h`;
                return `${m}m`;
            }

            formatTimestamp(ts) {
                return new Date(ts).toLocaleString(undefined, {
                    month: 'short', day: 'numeric', year: 'numeric',
                    hour: '2-digit', minute: '2-digit'
                });
            }

            escHtml(str) {
                return String(str)
                    .replace(/&/g, '&amp;').replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;').replace(/"/g, '&quot;');
            }

            search(query) {
                this.searchQuery = query;
                this.render();
            }

            render() {
                const container = document.getElementById('priceList');
                if (!container) return;
                const allItems = Object.values(this.data.items);
                const filtered = this.getFilteredItems();

                if (allItems.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">üí∞</div>
                            <h3>No items tracked yet</h3>
                            <p>Click <strong>+ Add Item</strong> to start tracking player vendor prices.</p>
                        </div>`;
                    return;
                }

                if (filtered.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">üîç</div>
                            <h3>No items match your search</h3>
                            <p>Try a different search term.</p>
                        </div>`;
                    return;
                }

                container.innerHTML = filtered.map(item => this.renderItem(item)).join('');
                this.attachHandlers();
            }

            renderItem(item) {
                const stats = this.calcStats(item.entries);
                const isExpanded = this.expandedItems.has(item.id);

                let statsHtml;
                if (stats.count > 0) {
                    const countLabel = stats.totalCount > stats.count
                        ? `${stats.count}/${stats.totalCount} entries`
                        : `${stats.count} entr${stats.count === 1 ? 'y' : 'ies'}`;
                    statsHtml = `
                        <span class="price-stat">Low: <strong>${Math.round(stats.lowPrice).toLocaleString()}g</strong></span>
                        <span class="price-stat">Avg: <strong>${Math.round(stats.avgPrice).toLocaleString()}g</strong></span>
                        <span class="price-stat">Avg age: <strong>${this.formatAge(stats.avgAgeMs)}</strong></span>
                        <span class="price-stat">${countLabel}</span>`;
                } else if (stats.totalCount > 0) {
                    statsHtml = `<span class="price-stat" style="font-style:italic;">${stats.totalCount} retired</span>`;
                } else {
                    statsHtml = `<span class="price-stat" style="font-style:italic;">No entries yet</span>`;
                }

                const entriesHtml = item.entries.length > 0
                    ? `<table class="price-entries-table">
                        <thead><tr>
                            <th>Location</th>
                            <th>Price</th>
                            <th>Recorded</th>
                            <th>Age</th>
                            <th style="text-align:right">Actions</th>
                        </tr></thead>
                        <tbody>${item.entries.map(e => this.renderEntry(item.id, e)).join('')}</tbody>
                       </table>`
                    : `<div style="padding:14px 20px;color:#6c757d;font-style:italic;font-size:0.9em;">No price entries yet ‚Äî click <strong>Add Entry</strong> to log a price.</div>`;

                return `
                    <div class="price-item-accordion" data-item-id="${item.id}">
                        <div class="price-item-header${isExpanded ? ' expanded' : ''}" data-toggle-item="${item.id}">
                            <span class="price-item-name">${this.escHtml(item.name)}</span>
                            <div class="price-item-stats">${statsHtml}</div>
                            <button class="price-item-delete-btn" data-delete-item="${item.id}" title="Delete item">‚úï</button>
                            <span class="price-item-arrow">‚ñº</span>
                        </div>
                        <div class="price-item-content${isExpanded ? ' expanded' : ''}">
                            ${entriesHtml}
                            <div class="price-add-entry-row">
                                <button class="btn-add-entry" data-add-entry="${item.id}">+ Add Entry</button>
                            </div>
                        </div>
                    </div>`;
            }

            renderEntry(itemId, entry) {
                const age = this.formatAge(Date.now() - entry.timestamp);
                const date = this.formatTimestamp(entry.timestamp);
                const retiredClass = entry.retired ? ' price-entry-retired' : '';
                const retireLabel = entry.retired ? 'Unretire' : 'Retire';
                const retireBtnClass = entry.retired ? 'btn-unretire' : 'btn-retire';
                return `
                    <tr class="${retiredClass}">
                        <td class="entry-location">${this.escHtml(entry.location || '‚Äî')}</td>
                        <td class="entry-price">${entry.price.toLocaleString()}g</td>
                        <td class="entry-date">${date}</td>
                        <td class="entry-age">${age}</td>
                        <td>
                            <div class="entry-actions">
                                <button class="entry-btn btn-edit"    data-edit-entry="${entry.id}"   data-item-id="${itemId}">Edit</button>
                                <button class="entry-btn ${retireBtnClass}" data-retire-entry="${entry.id}" data-item-id="${itemId}">${retireLabel}</button>
                                <button class="entry-btn btn-delete"  data-delete-entry="${entry.id}" data-item-id="${itemId}">Delete</button>
                            </div>
                        </td>
                    </tr>`;
            }

            attachHandlers() {
                const container = document.getElementById('priceList');

                container.querySelectorAll('[data-toggle-item]').forEach(el => {
                    el.addEventListener('click', (e) => {
                        if (e.target.closest('[data-delete-item]')) return;
                        const id = el.getAttribute('data-toggle-item');
                        if (this.expandedItems.has(id)) this.expandedItems.delete(id);
                        else this.expandedItems.add(id);
                        this.render();
                    });
                });

                container.querySelectorAll('[data-delete-item]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.deleteItem(btn.getAttribute('data-delete-item'));
                    });
                });

                container.querySelectorAll('[data-add-entry]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this._editingItemId = btn.getAttribute('data-add-entry');
                        this._editingEntryId = null;
                        this.openEntryModal();
                    });
                });

                container.querySelectorAll('[data-edit-entry]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this._editingItemId = btn.getAttribute('data-item-id');
                        this._editingEntryId = btn.getAttribute('data-edit-entry');
                        this.openEntryModal();
                    });
                });

                container.querySelectorAll('[data-retire-entry]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.retireEntry(btn.getAttribute('data-item-id'), btn.getAttribute('data-retire-entry'));
                    });
                });

                container.querySelectorAll('[data-delete-entry]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        if (!confirm('Delete this price entry?')) return;
                        this.deleteEntry(btn.getAttribute('data-item-id'), btn.getAttribute('data-delete-entry'));
                    });
                });
            }

            openEntryModal() {
                const item = this.data.items[this._editingItemId];
                const isEdit = !!this._editingEntryId;
                const entry = isEdit ? item.entries.find(e => e.id === this._editingEntryId) : null;

                document.getElementById('priceModalTitle').textContent =
                    isEdit ? `Edit Entry ‚Äî ${item.name}` : `Add Entry ‚Äî ${item.name}`;
                document.getElementById('priceModalLocation').value = entry ? entry.location : '';
                document.getElementById('priceModalPrice').value = entry ? entry.price : '';

                const ts = entry ? entry.timestamp : Date.now();
                const dt = new Date(ts - new Date().getTimezoneOffset() * 60000).toISOString().slice(0, 16);
                document.getElementById('priceModalTimestamp').value = dt;

                document.getElementById('priceEntryModal').style.display = 'flex';
                document.getElementById('priceModalLocation').focus();
            }

            saveEntryModal() {
                const location = document.getElementById('priceModalLocation').value.trim();
                const price = parseFloat(document.getElementById('priceModalPrice').value);
                const tsStr = document.getElementById('priceModalTimestamp').value;

                if (isNaN(price) || price < 0) { alert('Please enter a valid price.'); return; }

                const timestamp = tsStr ? new Date(tsStr).getTime() : Date.now();

                if (this._editingEntryId) {
                    this.editEntry(this._editingItemId, this._editingEntryId, { location, price, timestamp });
                } else {
                    this.addEntry(this._editingItemId, { location, price, timestamp });
                }
                document.getElementById('priceEntryModal').style.display = 'none';
            }

            // Find an existing item by exact name (case-insensitive) or create it
            findOrCreateItem(name) {
                const lower = name.toLowerCase();
                const existing = Object.values(this.data.items).find(i => i.name.toLowerCase() === lower);
                if (existing) return existing.id;
                const id = generateId();
                this.data.items[id] = { id, name: name.trim(), entries: [] };
                savePriceTrackerData(this.data);
                this.render();
                return id;
            }

            // Open the price-entry modal pre-filled with a location; focuses the price field
            quickAddEntry(itemName, location) {
                const itemId = this.findOrCreateItem(itemName);
                this._editingItemId = itemId;
                this._editingEntryId = null;
                document.getElementById('priceModalLocation').value = location;
                document.getElementById('priceModalPrice').value = '';
                const dt = new Date(Date.now() - new Date().getTimezoneOffset() * 60000).toISOString().slice(0, 16);
                document.getElementById('priceModalTimestamp').value = dt;
                document.getElementById('priceEntryModal').style.display = 'flex';
                document.getElementById('priceModalPrice').focus();
            }
        }

        // Application initialization
        let currentCharacterKey = null;   // e.g. "Kaeus" or "Kaeus:Server"
        let availableCharacters = [];     // [{filename,baseName,charName,server,key,mtime,handle}]

        let dataLoader = new DataLoader();
        let questBrowser = new QuestBrowser(dataLoader);
        let inventoryBrowser = new InventoryBrowser(dataLoader);
        let storeBrowser = new StoreBrowser(dataLoader);
        let vendorPriceTracker = new VendorPriceTracker();
        let reportsDirectoryHandle = null;

        function showStatus(message, type = 'loading') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }

        // Migrate legacy (un-keyed) vendor/accordion data to the given character key
        function migrateLegacyData(charKey) {
            const legacyVendor = localStorage.getItem('gorgon-vendor-data');
            if (legacyVendor) {
                const target = 'gorgon-vendor-data:' + charKey;
                if (!localStorage.getItem(target)) localStorage.setItem(target, legacyVendor);
                localStorage.removeItem('gorgon-vendor-data');
            }
            const legacyAccordion = localStorage.getItem('gorgon-store-accordion');
            if (legacyAccordion) {
                const target = 'gorgon-store-accordion:' + charKey;
                if (!localStorage.getItem(target)) localStorage.setItem(target, legacyAccordion);
                localStorage.removeItem('gorgon-store-accordion');
            }
        }

        // Populate the character picker dropdown
        function renderCharacterPicker(characters) {
            const row = document.getElementById('characterPickerRow');
            const picker = document.getElementById('characterPicker');
            if (!row || !picker) return;
            if (characters.length === 0) { row.style.display = 'none'; return; }
            picker.innerHTML = characters.map(c => {
                const label = c.server ? `${c.charName} (${c.server})` : c.charName;
                return `<option value="${c.key}">${label}</option>`;
            }).join('');
            row.style.display = 'flex';
        }

        async function handleCharacterFileLoad(file) {
            try {
                showStatus('Loading character data...', 'loading');

                await dataLoader.loadCharacterFile(file);
                showStatus('Loading quest database from CDN...', 'loading');

                await dataLoader.loadQuestData();
                showStatus(`‚úì Loaded ${dataLoader.characterData.Character}'s data with ${dataLoader.characterData.ActiveQuests.length} active quests`, 'success');

                await questBrowser.initialize();
                storeBrowser.initialize();
            } catch (error) {
                showStatus(`‚úó Error: ${error.message}`, 'error');
                console.error('Load error:', error);
            }
        }

        async function handleItemsFileLoad(file) {
            try {
                showStatus('Loading items data...', 'loading');

                await dataLoader.loadItemsFile(file);
                showStatus('Loading item database from CDN...', 'loading');

                await dataLoader.loadInventoryData();
                showStatus(`‚úì Loaded ${dataLoader.itemsData.Items.length} items from storage`, 'success');

                await inventoryBrowser.initialize();
            } catch (error) {
                showStatus(`‚úó Error: ${error.message}`, 'error');
                console.error('Load error:', error);
            }
        }

        // Persist the chosen directory handle in IndexedDB so the picker
        // remembers the location even when the page is opened via file://.
        async function openHandlesDB() {
            return new Promise((resolve, reject) => {
                const req = indexedDB.open('GorgonTrackerDB', 1);
                req.onupgradeneeded = (e) => e.target.result.createObjectStore('handles');
                req.onsuccess = (e) => resolve(e.target.result);
                req.onerror = (e) => reject(e.target.error);
            });
        }

        async function saveDirectoryHandle(handle) {
            try {
                const db = await openHandlesDB();
                const tx = db.transaction('handles', 'readwrite');
                tx.objectStore('handles').put(handle, 'reportsDir');
                await new Promise(resolve => { tx.oncomplete = resolve; });
            } catch (e) { /* non-critical */ }
        }

        async function getSavedDirectoryHandle() {
            try {
                const db = await openHandlesDB();
                return await new Promise(resolve => {
                    const req = db.transaction('handles', 'readonly').objectStore('handles').get('reportsDir');
                    req.onsuccess = (e) => resolve(e.target.result || null);
                    req.onerror = () => resolve(null);
                });
            } catch (e) { return null; }
        }

        async function selectReportsFolder() {
            try {
                const savedHandle = await getSavedDirectoryHandle();
                const pickerOpts = { id: 'gorgon-reports', mode: 'read' };
                if (savedHandle) pickerOpts.startIn = savedHandle;
                reportsDirectoryHandle = await window.showDirectoryPicker(pickerOpts);
                await saveDirectoryHandle(reportsDirectoryHandle);
                const btn = document.getElementById('selectFolderBtn');
                btn.textContent = '‚úì Folder Selected';
                btn.style.background = '#d4edda';
                btn.style.color = '#155724';
                btn.style.borderColor = '#28a745';
                await loadAllDataFromDirectory(reportsDirectoryHandle);
            } catch (e) {
                if (e.name !== 'AbortError') {
                    showStatus(`‚úó Folder error: ${e.message}`, 'error');
                }
            }
        }

        async function loadAllDataFromDirectory(dirHandle, charOverride = null) {
            if (isLoadingData) return;
            isLoadingData = true;
            try {
                showStatus('Loading character data from folder...', 'loading');

                // Resolve reports dir and cache it so loadItemsFromDirectory can reuse it
                const reportsDir = await dataLoader.resolveReportsDir(dirHandle);
                dataLoader._reportsDir = reportsDir;

                // Scan all available character files and populate the picker
                availableCharacters = await dataLoader.scanCharacterFiles(reportsDir);
                renderCharacterPicker(availableCharacters);

                // Determine which character to load
                let charToLoad = charOverride;
                if (!charToLoad) {
                    const lastKey = localStorage.getItem('gorgon-last-character');
                    charToLoad = (lastKey && availableCharacters.find(c => c.key === lastKey))
                        || availableCharacters[0];
                }
                if (!charToLoad) throw new Error('No Character_*.json found in selected folder');

                // Commit character context
                currentCharacterKey = charToLoad.key;
                localStorage.setItem('gorgon-last-character', currentCharacterKey);

                // Sync picker to selection
                const picker = document.getElementById('characterPicker');
                if (picker) picker.value = currentCharacterKey;

                // One-time migration of un-keyed legacy data ‚Üí this character's key
                migrateLegacyData(currentCharacterKey);

                // Load the selected character file
                await dataLoader.loadCharacterFromHandle(charToLoad.handle, charToLoad.baseName);

                showStatus('Loading items data from folder...', 'loading');
                await dataLoader.loadItemsFromDirectory(dirHandle);

                showStatus('Loading reference data from CDN...', 'loading');
                await dataLoader.loadQuestData();
                await dataLoader.loadInventoryData();

                await questBrowser.initialize();
                await inventoryBrowser.initialize();
                storeBrowser.initialize();

                showStatus(
                    `‚úì Loaded ${dataLoader.characterData.Character}'s data: ${dataLoader.characterData.ActiveQuests.length} quests, ${dataLoader.itemsData.Items.length} items`,
                    'success'
                );

                // Record max mtime of data files so watcher can detect future changes
                try {
                    let maxMtime = 0;
                    for await (const [name, handle] of reportsDir.entries()) {
                        if (handle.kind !== 'file' || !name.endsWith('.json')) continue;
                        if (!name.startsWith('Character_') && !name.includes('_items_')) continue;
                        const f = await handle.getFile();
                        if (f.lastModified > maxMtime) maxMtime = f.lastModified;
                    }
                    lastLoadedMtime = maxMtime;
                } catch (e) { /* non-critical */ }

                startReportsWatcher();
                updateReportsWatchStatus(true);
            } catch (error) {
                showStatus(`‚úó Error: ${error.message}`, 'error');
                console.error('Load error:', error);
            } finally {
                isLoadingData = false;
            }
        }

        async function loadAllDataFromAPI() {
            try {
                showStatus('Loading game data from disk...', 'loading');

                showStatus('Loading quest database from CDN...', 'loading');
                await dataLoader.loadQuestData();

                showStatus('Loading item database from CDN...', 'loading');
                await dataLoader.loadInventoryData();

                // Initialize all browsers
                await questBrowser.initialize();
                await inventoryBrowser.initialize();
                storeBrowser.initialize();

                showStatus(
                    `‚úì Loaded CDN data: Please load character data!`,
                    'success'
                );

            } catch (error) {
                showStatus(`‚úó Error: ${error.message}. Use Manual File Loading below.`, 'error');
                console.error('Load error:', error);
            }
        }

        // Tab switching
        function switchTab(tabName, updateHash = true) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.getAttribute('data-tab') === tabName) {
                    tab.classList.add('active');
                }
            });

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabName).classList.add('active');

            // Update URL hash
            if (updateHash) {
                window.location.hash = tabName;
            }
        }

        // Handle hash changes (browser back/forward)
        function handleHashChange() {
            const hash = window.location.hash.slice(1); // Remove '#'
            const validTabs = ['quests', 'inventory', 'stores', 'prices', 'maps'];

            if (hash && validTabs.includes(hash)) {
                switchTab(hash, false); // Don't update hash again to avoid loop
            }
        }

        // Initialize tab from URL hash on page load
        function initializeTabFromHash() {
            const hash = window.location.hash.slice(1);
            const validTabs = ['quests', 'inventory', 'stores', 'prices', 'maps'];

            if (hash && validTabs.includes(hash)) {
                switchTab(hash, false);
            }
        }

        // Event listeners
        document.getElementById('characterFile').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleCharacterFileLoad(file);
            }
        });

        document.getElementById('itemsFile').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleItemsFileLoad(file);
            }
        });

        document.getElementById('questSearch').addEventListener('input', (e) => {
            questBrowser.search(e.target.value);
        });

        document.getElementById('inventorySearch').addEventListener('input', (e) => {
            inventoryBrowser.search(e.target.value);
        });

        document.getElementById('priceSearch').addEventListener('input', (e) => {
            vendorPriceTracker.search(e.target.value);
        });

        document.getElementById('addItemBtn').addEventListener('click', () => {
            document.getElementById('addItemName').value = '';
            document.getElementById('addItemModal').style.display = 'flex';
            document.getElementById('addItemName').focus();
        });

        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                switchTab(tab.getAttribute('data-tab'));
            });
        });

        document.getElementById('characterPicker').addEventListener('change', (e) => {
            const key = e.target.value;
            const char = availableCharacters.find(c => c.key === key);
            if (char && reportsDirectoryHandle) {
                loadAllDataFromDirectory(reportsDirectoryHandle, char);
            }
        });

        // Price tracker modal handlers ‚Äî deferred until modals are in the DOM
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('addItemModalClose').onclick = () => {
                document.getElementById('addItemModal').style.display = 'none';
            };
            document.getElementById('addItemSave').onclick = () => {
                const name = document.getElementById('addItemName').value.trim();
                if (!name) { alert('Please enter an item name.'); return; }
                vendorPriceTracker.addItem(name);
                document.getElementById('addItemModal').style.display = 'none';
            };
            document.getElementById('addItemName').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') document.getElementById('addItemSave').click();
            });

            document.getElementById('priceModalClose').onclick = () => {
                document.getElementById('priceEntryModal').style.display = 'none';
            };
            document.getElementById('priceModalSave').onclick = () => {
                vendorPriceTracker.saveEntryModal();
            };
            document.getElementById('priceModalPrice').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') document.getElementById('priceModalSave').click();
            });
        });

        // Handle hash changes for tab navigation
        window.addEventListener('hashchange', handleHashChange);

        // Initialize tab from URL hash
        initializeTabFromHash();

        // Auto-load data on page load
        loadAllDataFromAPI();

        // Restore saved handles if permission was already granted this session
        (async () => {
            const [savedFolder, savedLog] = await Promise.all([
                getSavedDirectoryHandle(),
                getSavedPlayerLogHandle(),
            ]);

            if (savedFolder) {
                try {
                    const perm = await savedFolder.queryPermission({ mode: 'read' });
                    if (perm === 'granted') {
                        reportsDirectoryHandle = savedFolder;
                        const btn = document.getElementById('selectFolderBtn');
                        if (btn) { btn.textContent = '‚úì Folder Selected'; btn.style.background = '#d4edda'; btn.style.color = '#155724'; btn.style.borderColor = '#28a745'; }
                        loadAllDataFromDirectory(savedFolder);
                    }
                } catch { /* stale handle, ignore */ }
            }

            if (savedLog) {
                try {
                    const perm = await savedLog.queryPermission({ mode: 'read' });
                    if (perm === 'granted') {
                        playerLogFileHandle = savedLog;
                        playerLogOffset = (await savedLog.getFile()).size;
                        startPlayerLogWatcher();
                        updatePlayerLogStatus(true);
                    }
                } catch { /* stale handle, ignore */ }
            }
        })();

        // Show empty state initially
        document.getElementById('questList').innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">üìÅ</div>
                <h3>No character data loaded</h3>
                <p>Select your Character.json file or Reports folder above to get started.</p>
            </div>
        `;

        document.getElementById('inventoryList').innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">üìÅ</div>
                <h3>No items data loaded</h3>
                <p>Select your *_items_*.json file or Reports folderabove to get started.</p>
            </div>
        `;

        document.getElementById('storeList').innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">üõí</div>
                <h3>No store data loaded</h3>
                <p>Click Reload Game Data to load merchant stores.</p>
            </div>
        `;

        // Render price tracker on load (uses localStorage, no data files needed)
        vendorPriceTracker.render();

        // Close modals on Escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                document.getElementById('trackerModal').style.display = 'none';
                document.getElementById('priceEntryModal').style.display = 'none';
                document.getElementById('addItemModal').style.display = 'none';
            }
        });
    </script>

    <div id="trackerModal" class="tracker-modal-overlay" style="display:none;">
        <div class="tracker-modal">
            <div class="tracker-modal-header">
                <span class="tracker-modal-title" id="trackerModalTitle">Track Vendor</span>
                <button class="tracker-modal-close" id="trackerModalCloseBtn">‚úï</button>
            </div>
            <div class="tracker-modal-body">
                <div class="tracker-popup-label" style="margin-top:0">Remaining gold</div>
                <input type="number" id="trackerModalRemaining" class="tracker-remaining-input" placeholder="e.g. 5000" min="0">
                <div class="tracker-popup-label">Resets in</div>
                <div class="tracker-reset-inputs">
                    <input type="number" id="trackerModalDays"  placeholder="0" min="0"> d
                    <input type="number" id="trackerModalHours" placeholder="0" min="0" max="23"> h
                    <input type="number" id="trackerModalMins"  placeholder="0" min="0" max="59"> m
                </div>
            </div>
            <div class="tracker-modal-footer">
                <button class="tracker-save-btn" id="trackerModalSave">Save</button>
                <button class="tracker-clear-btn" id="trackerModalClear">Clear</button>
            </div>
        </div>
    </div>

    <div id="captureToast" class="capture-toast" style="display:none;"></div>

    <!-- Add Item modal -->
    <div id="addItemModal" class="tracker-modal-overlay" style="display:none;">
        <div class="price-modal">
            <div class="price-modal-header">
                <span class="price-modal-title">Track New Item</span>
                <button class="price-modal-close" id="addItemModalClose">‚úï</button>
            </div>
            <div class="price-modal-body">
                <div>
                    <label class="price-modal-label" for="addItemName">Item Name</label>
                    <input type="text" id="addItemName" class="price-modal-input" placeholder="e.g. Saddled Horse">
                </div>
            </div>
            <div class="price-modal-footer">
                <button class="tracker-save-btn" id="addItemSave">Add Item</button>
            </div>
        </div>
    </div>

    <!-- Add / Edit price entry modal -->
    <div id="priceEntryModal" class="tracker-modal-overlay" style="display:none;">
        <div class="price-modal">
            <div class="price-modal-header">
                <span class="price-modal-title" id="priceModalTitle">Add Entry</span>
                <button class="price-modal-close" id="priceModalClose">‚úï</button>
            </div>
            <div class="price-modal-body">
                <div>
                    <label class="price-modal-label" for="priceModalLocation">Location / Vendor</label>
                    <input type="text" id="priceModalLocation" class="price-modal-input" placeholder="e.g. Serbule, Ivan's Cart">
                </div>
                <div>
                    <label class="price-modal-label" for="priceModalPrice">Price (gold)</label>
                    <input type="number" id="priceModalPrice" class="price-modal-input" placeholder="e.g. 5000" min="0" step="1">
                </div>
                <div>
                    <label class="price-modal-label" for="priceModalTimestamp">Recorded At</label>
                    <input type="datetime-local" id="priceModalTimestamp" class="price-modal-input">
                </div>
            </div>
            <div class="price-modal-footer">
                <button class="tracker-save-btn" id="priceModalSave">Save</button>
            </div>
        </div>
    </div>
</body>
</html>
