<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Gorgon Quest/Inventory Tracker</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>üó°Ô∏è Project Gorgon Quest/Inventory Tracker</h1>
            <p>Search your Quests, search your Inventory, track Vendor favor/limits</p>
        </header>

        <div class="nav">
            <b>Quest/Inventory Tracker</b>
            <a href="maps.html">Interactive Maps</a>
            <a href="chat-watcher.html">Chat Watcher</a>
        </div>

        <div class="file-loader">
            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                <button id="reloadBtn" style="flex: 1; padding: 12px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 1em;">
                    üîÑ Reload Game Data
                </button>
                <button id="selectFolderBtn" onclick="selectReportsFolder()" style="padding: 12px 16px; background: white; color: #667eea; border: 2px solid #667eea; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 1em; white-space: nowrap;">
                    üìÇ Select Folder
                </button>
            </div>
            <div style="font-size: 0.8em; color: #6c757d; margin-bottom: 10px;">
                Reports folder: <code style="background: #f0f0f0; padding: 1px 5px; border-radius: 3px;">%LocalAppData%Low\Elder Game\Project Gorgon\Reports</code>
            </div>
            <details style="margin-top: 10px;">
                <summary style="cursor: pointer; padding: 10px; background: #f8f9fa; border-radius: 6px; font-weight: 600;">Manual File Loading</summary>
                <div style="padding: 15px 0;">
                    <div class="file-input-group">
                        <label for="characterFile">Character Data:</label>
                        <input type="file" id="characterFile" accept=".json">
                    </div>
                    <div class="file-input-group">
                        <label for="itemsFile">Items Data:</label>
                        <input type="file" id="itemsFile" accept=".json">
                    </div>
                </div>
            </details>
            <div id="status" class="status"></div>
        </div>

        <div class="tabs">
            <div class="tab active" data-tab="quests">üìú Quests</div>
            <div class="tab" data-tab="inventory">üéí Inventory</div>
            <div class="tab" data-tab="stores">üõí Vendors</div>
        </div>

        <div id="quests" class="tab-content active quest-browser">
            <div id="questStats" class="quest-stats" style="display: none;">
                <div class="stat-card">
                    <div class="number" id="totalQuests">0</div>
                    <div class="label">Active Quests</div>
                </div>
                <div class="stat-card">
                    <div class="number" id="goldAmount">0</div>
                    <div class="label">Gold</div>
                </div>
            </div>

            <div id="questSearchBar" class="search-bar" style="display: none;">
                <input type="text" id="questSearch" placeholder="üîç Search quests by name, NPC, or description...">
            </div>

            <div id="questList" class="quest-list"></div>
        </div>

        <div id="inventory" class="tab-content inventory-browser">
            <div id="inventoryStats" class="quest-stats" style="display: none;">
                <div class="stat-card">
                    <div class="number" id="totalItems">0</div>
                    <div class="label">Total Items</div>
                </div>
                <div class="stat-card">
                    <div class="number" id="totalValue">0</div>
                    <div class="label">Total Value</div>
                </div>
                <div class="stat-card">
                    <div class="number" id="vaultCount">0</div>
                    <div class="label">Storage Vaults</div>
                </div>
            </div>

            <div id="inventorySearchBar" class="search-bar" style="display: none;">
                <input type="text" id="inventorySearch" placeholder="üîç Search items by name...">
            </div>

            <div id="inventoryList" class="quest-list"></div>
        </div>

        <div id="stores" class="tab-content stores-browser">
            <div class="player-log-bar">
                <button id="selectPlayerLogBtn" class="btn-secondary player-log-btn" onclick="selectPlayerLogFile()">üìã Watch Player.log</button>
                <span id="playerLogStatus" class="player-log-status">Select Player.log to auto-capture vendor data when you open shops in-game.</span>
            </div>
            <div id="storeList"></div>
        </div>
    </div>

    <script>
        // Data Loader
        class DataLoader {
            constructor() {
                this.characterData = null;
                this.itemsData = null;
                this.questsData = null;
                this.npcsData = null;
                this.cdnItemsData = null;
                this.storageVaultsData = null;
                this.cdnBaseUrl = 'https://cdn.projectgorgon.com/v457/data/';
            }

            async loadCharacterFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            this.characterData = JSON.parse(e.target.result);
                            resolve(this.characterData);
                        } catch (error) {
                            reject(new Error('Invalid JSON file'));
                        }
                    };
                    reader.onerror = () => reject(new Error('Failed to read file'));
                    reader.readAsText(file);
                });
            }

            async fetchCDNData(filename) {
                const url = this.cdnBaseUrl + filename;
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Failed to fetch ${filename}`);
                }
                return await response.json();
            }

            async loadQuestData() {
                // Check in-memory cache first
                if (this.questsData && this.npcsData) {
                    return; // Already loaded in this session
                }

                // Fetch from CDN
                const [questsRaw, npcsRaw] = await Promise.all([
                    this.fetchCDNData('quests.json'),
                    this.fetchCDNData('npcs.json')
                ]);

                // Process quests into keyed lookup by InternalName
                this.questsData = this.processToKeyedLookup(questsRaw, 'InternalName');

                // Process NPCs into keyed lookup (they might use a different key)
                this.npcsData = this.processToKeyedLookup(npcsRaw, 'InternalName') || npcsRaw;
            }

            processToKeyedLookup(data, keyField) {
                // If already an object (not array), check if it needs processing
                if (!Array.isArray(data)) {
                    // Check if it's already keyed properly
                    const firstKey = Object.keys(data)[0];
                    if (firstKey && data[firstKey] && data[firstKey][keyField] === firstKey) {
                        return data; // Already properly keyed
                    }
                    // If it's an object with values that have the keyField, rekey it
                    const result = {};
                    for (const value of Object.values(data)) {
                        if (value && value[keyField]) {
                            result[value[keyField]] = value;
                        }
                    }
                    return Object.keys(result).length > 0 ? result : data;
                }

                // Process array into keyed object
                const result = {};
                for (const item of data) {
                    if (item && item[keyField]) {
                        result[item[keyField]] = item;
                    }
                }
                return result;
            }

            getQuestDetails(internalName) {
                if (!this.questsData || !this.questsData[internalName]) {
                    return {
                        InternalName: internalName,
                        Name: internalName,
                        Description: 'Quest details not found',
                        Objectives: [],
                        IsCategoryGate: false
                    };
                }
                return this.questsData[internalName];
            }

            getNPCName(npcId) {
                // Regex replace to sanitize the prefix before the NPC name, for example: AreaEltibule/NPC_Mythander -> NPC_Mythander
                npcId = (npcId || '').replace(/^[^/]*\//, '').trim();

                if (!this.npcsData || !this.npcsData[npcId]) {
                    return null;
                }
                return this.npcsData[npcId].Name || npcId;
            }

            async resolveReportsDir(dirHandle) {
                // Check if this dir contains a Character_*.json file
                const hasCharFile = await (async () => {
                    for await (const [name, handle] of dirHandle.entries()) {
                        if (handle.kind === 'file' && name.startsWith('Character_') && name.endsWith('.json')) return true;
                    }
                    return false;
                })();
                if (hasCharFile) return dirHandle;

                // Try navigating into a Reports subdirectory
                try {
                    return await dirHandle.getDirectoryHandle('Reports');
                } catch (_) {
                    throw new Error('No Character_*.json found. Select the Reports folder (or its parent Project Gorgon folder).');
                }
            }

            async loadCharacterFromDirectory(dirHandle) {
                const reportsDir = await this.resolveReportsDir(dirHandle);
                this._reportsDir = reportsDir;

                // Find the most recently modified Character_*.json
                let latestHandle = null, latestMtime = 0;
                for await (const [name, handle] of reportsDir.entries()) {
                    if (handle.kind === 'file' && name.startsWith('Character_') && name.endsWith('.json')) {
                        const f = await handle.getFile();
                        if (f.lastModified > latestMtime) {
                            latestMtime = f.lastModified;
                            latestHandle = handle;
                            this._charFileBaseName = name.replace(/^Character_/, '').replace(/\.json$/, '');
                        }
                    }
                }
                if (!latestHandle) throw new Error('No Character_*.json found in selected folder');
                const file = await latestHandle.getFile();
                this.characterData = JSON.parse(await file.text());
                return this.characterData;
            }

            async loadItemsFromDirectory(dirHandle) {
                const reportsDir = this._reportsDir || await this.resolveReportsDir(dirHandle);
                // Use character base name (e.g. "Kaeus_SomeServer") derived from the character file
                const charBase = this._charFileBaseName || '';
                let latestHandle = null, latestName = '';
                for await (const [name, handle] of reportsDir.entries()) {
                    if (handle.kind === 'file' && name.endsWith('.json') &&
                        name.includes('_items_') &&
                        (charBase ? name.startsWith(charBase + '_items_') : true) &&
                        name > latestName) {
                        latestName = name;
                        latestHandle = handle;
                    }
                }
                if (!latestHandle) throw new Error('No *_items_*.json found in selected folder');
                const file = await latestHandle.getFile();
                this.itemsData = JSON.parse(await file.text());
                return this.itemsData;
            }

            async loadItemsFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            this.itemsData = JSON.parse(e.target.result);
                            resolve(this.itemsData);
                        } catch (error) {
                            reject(new Error('Invalid JSON file'));
                        }
                    };
                    reader.onerror = () => reject(new Error('Failed to read file'));
                    reader.readAsText(file);
                });
            }

            async loadInventoryData() {
                // Check in-memory cache first
                if (this.cdnItemsData && this.storageVaultsData) {
                    return; // Already loaded in this session
                }

                // Fetch from CDN
                const [itemsRaw, vaultsRaw] = await Promise.all([
                    this.fetchCDNData('items.json'),
                    this.fetchCDNData('storagevaults.json')
                ]);

                // Process into keyed lookups
                this.cdnItemsData = this.processToKeyedLookup(itemsRaw, 'InternalName');
                this.storageVaultsData = this.processToKeyedLookup(vaultsRaw, 'InternalName') || vaultsRaw;
            }

            getItemDetails(typeId) {
                if (!this.cdnItemsData) return null;

                // CDN items might be keyed by numeric ID or InternalName
                // Try direct lookup first
                let item = this.cdnItemsData[typeId];
                if (item) return item;

                // Search by Id field
                for (const itemData of Object.values(this.cdnItemsData)) {
                    if (itemData.Id === typeId) {
                        return itemData;
                    }
                }
                return null;
            }

            getVaultName(internalName) {
                if (!this.storageVaultsData || !this.storageVaultsData[internalName]) {
                    return internalName || 'Inventory';
                }
                return this.storageVaultsData[internalName].Name || internalName;
            }
        }

        // Quest Browser
        class QuestBrowser {
            constructor(dataLoader) {
                this.dataLoader = dataLoader;
                this.allQuests = [];
                this.filteredQuests = [];
            }

            async initialize() {
                if (!this.dataLoader.characterData || !this.dataLoader.questsData) {
                    return;
                }

                // Build quest list with details
                this.allQuests = this.dataLoader.characterData.ActiveQuests.map(internalName => {
                    const questData = this.dataLoader.getQuestDetails(internalName);
                    const npcName = this.dataLoader.getNPCName(questData.FavorNpc);

                    return {
                        internalName,
                        ...questData,
                        npcName
                    };
                });

                this.filteredQuests = [...this.allQuests];
                this.render();
                this.updateStats();
            }

            updateStats() {
                const characterData = this.dataLoader.characterData;

                document.getElementById('totalQuests').textContent = this.allQuests.length;
                document.getElementById('goldAmount').textContent = characterData.Currencies.GOLD.toLocaleString();

                document.getElementById('questStats').style.display = 'grid';
                document.getElementById('questSearchBar').style.display = 'block';
            }

            search(query) {
                const lowerQuery = query.toLowerCase();
                this.filteredQuests = this.allQuests.filter(quest => {
                    // Search in basic fields
                    if (quest.Name?.toLowerCase().includes(lowerQuery) ||
                        quest.Description?.toLowerCase().includes(lowerQuery) ||
                        quest.npcName?.toLowerCase().includes(lowerQuery) ||
                        quest.FavorNpc?.toLowerCase().includes(lowerQuery) ||
                        quest.internalName?.toLowerCase().includes(lowerQuery)) {
                        return true;
                    }

                    // Search in objectives
                    if (quest.Objectives && Array.isArray(quest.Objectives)) {
                        for (const obj of quest.Objectives) {
                            const objText = typeof obj === 'string' ? obj : JSON.stringify(obj);
                            if (objText.toLowerCase().includes(lowerQuery)) {
                                return true;
                            }
                        }
                    }

                    return false;
                });
                this.render();
            }

            buildQuickObjectives() {
                const objectivesByZone = {};

                for (const quest of this.filteredQuests) {
                    const zone = quest.DisplayedLocation || 'Unknown Location';
                    if (!objectivesByZone[zone]) {
                        objectivesByZone[zone] = [];
                    }

                    if (quest.Objectives && Array.isArray(quest.Objectives)) {
                        for (const objective of quest.Objectives) {
                            const objText = objective.Description || (typeof objective === 'string' ? objective : JSON.stringify(objective));

                            // Filter out "Talk to" or "Return to" objectives (turn-in objectives)
                            if (!(objText).match(/^(Talk to|Return to|Speak with|Speak to)/i)) {
                                objectivesByZone[zone].push({
                                    text: objText,
                                    questName: quest.Name
                                });
                            }
                        }
                    }
                }

                return objectivesByZone;
            }

            renderQuickObjectives() {
                const objectivesByZone = this.buildQuickObjectives();
                const zones = Object.keys(objectivesByZone).sort();

                if (zones.length === 0) {
                    return '';
                }

                const zonesHTML = zones.map((zone, index) => {
                    const objectives = objectivesByZone[zone];
                    if (objectives.length === 0) return '';

                    const zoneId = `quick-zone-${zone.replace(/\s+/g, '-').toLowerCase()}`;

                    return `
                        <div class="quick-objectives-zone">
                            <div class="quick-objectives-zone-header" data-zone="${zoneId}">
                                <div class="quick-objectives-zone-title">
                                    <span>üìç ${zone}</span>
                                    <span class="quest-count-badge">${objectives.length}</span>
                                </div>
                                <div class="accordion-icon">‚ñº</div>
                            </div>
                            <div id="${zoneId}" class="quick-objectives-zone-content">
                                <ul class="quick-objectives-list">
                                    ${objectives.map(obj => {
                                        const wikiSearchUrl = `https://wiki.projectgorgon.com/wiki/?search=${encodeURIComponent(obj.questName)}`;
                                        return `
                                            <li class="quick-objective-item">
                                                <span class="quick-objective-text">${obj.text}</span>
                                                <span class="quick-objective-quest"><a href="${wikiSearchUrl}" target="_blank" rel="noopener noreferrer">${obj.questName}</a></span>
                                            </li>
                                        `;
                                    }).join('')}
                                </ul>
                            </div>
                        </div>
                    `;
                }).join('');

                return `
                    <div class="quick-objectives-section">
                        <div class="quick-objectives-header" id="quickObjectivesToggle">
                            <div class="quick-objectives-title">
                                <span>‚ö° Quick Objectives</span>
                                <span class="quest-count-badge">${Object.values(objectivesByZone).flat().length} objectives</span>
                            </div>
                            <div class="accordion-icon">‚ñº</div>
                        </div>
                        <div class="quick-objectives-content active" id="quickObjectivesContent">
                            ${zonesHTML}
                        </div>
                    </div>
                `;
            }

            render() {
                const container = document.getElementById('questList');

                if (this.filteredQuests.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">üìú</div>
                            <h3>No quests found</h3>
                            <p>Try adjusting your search or load character data.</p>
                        </div>
                    `;
                    return;
                }

                // Build quick objectives section
                const quickObjectivesHTML = this.renderQuickObjectives();

                // Group quests by DisplayedLocation
                const groupedQuests = this.groupByLocation(this.filteredQuests);

                // Render quick objectives + accordions for each location
                container.innerHTML = quickObjectivesHTML + Object.entries(groupedQuests)
                    .sort(([a], [b]) => a.localeCompare(b))
                    .map(([location, quests]) => this.renderLocationAccordion(location, quests))
                    .join('');

                // Add click handlers for accordions
                this.attachAccordionHandlers();
            }

            groupByLocation(quests) {
                const grouped = {};
                for (const quest of quests) {
                    const location = quest.DisplayedLocation || 'Unknown Location';
                    if (!grouped[location]) {
                        grouped[location] = [];
                    }
                    grouped[location].push(quest);
                }
                return grouped;
            }

            renderLocationAccordion(location, quests) {
                const accordionId = `accordion-${location.replace(/\s+/g, '-').toLowerCase()}`;
                return `
                    <div class="location-accordion">
                        <div class="accordion-header" data-accordion="${accordionId}">
                            <div class="accordion-title">
                                <span>üìç ${location}</span>
                                <span class="quest-count-badge">${quests.length} quest${quests.length !== 1 ? 's' : ''}</span>
                            </div>
                            <div class="accordion-icon">‚ñº</div>
                        </div>
                        <div id="${accordionId}" class="accordion-content">
                            <div class="accordion-quests">
                                ${quests.map(quest => this.renderQuestCard(quest)).join('')}
                            </div>
                        </div>
                    </div>
                `;
            }

            attachAccordionHandlers() {
                const container = document.getElementById('questList');

                // Handle quest accordion headers
                const headers = container.querySelectorAll('.accordion-header');
                headers.forEach(header => {
                    header.addEventListener('click', () => {
                        const accordionId = header.getAttribute('data-accordion');
                        const content = document.getElementById(accordionId);

                        // Toggle active state
                        header.classList.toggle('active');
                        content.classList.toggle('active');
                    });
                });

                // Handle quick objectives toggle
                const quickObjToggle = document.getElementById('quickObjectivesToggle');
                if (quickObjToggle) {
                    quickObjToggle.addEventListener('click', () => {
                        const content = document.getElementById('quickObjectivesContent');
                        quickObjToggle.classList.toggle('active');
                        content.classList.toggle('active');
                    });
                }

                // Handle quick objectives zone toggles
                const zoneHeaders = container.querySelectorAll('.quick-objectives-zone-header');
                zoneHeaders.forEach(header => {
                    header.addEventListener('click', () => {
                        const zoneId = header.getAttribute('data-zone');
                        const content = document.getElementById(zoneId);
                        header.classList.toggle('active');
                        content.classList.toggle('active');
                    });
                });
            }

            renderQuestCard(quest) {
                const objectives = quest.Objectives || [];
                const rewards = this.formatRewards(quest);
                const level = quest.Level || quest.MidLevel || '?';
                const questName = quest.Name || quest.internalName;
                const wikiSearchUrl = `https://wiki.projectgorgon.com/wiki/?search=${encodeURIComponent(questName)}`;

                return `
                    <div class="quest-card">
                        <div class="quest-header">
                            <div>
                                <div class="quest-title"><a href="${wikiSearchUrl}" target="_blank" rel="noopener noreferrer">${questName}</a></div>
                                ${quest.npcName ? `<div class="quest-npc">üìç ${quest.npcName}</div>` : ''}
                            </div>
                            ${quest.Reward_Favor ? `<div class="quest-level">${quest.Reward_Favor}fv</div>` : ''}
                        </div>

                        ${quest.Description ? `<div class="quest-description">${quest.Description}</div>` : ''}

                        ${objectives.length > 0 ? `
                            <div class="quest-objectives">
                                <h4>Objectives</h4>
                                <ul>
                                    ${objectives.map(obj => `
                                        <li>${this.formatObjective(obj)}</li>
                                    `).join('')}
                                </ul>
                            </div>
                        ` : ''}

                        ${rewards.length > 0 ? `
                            <div class="quest-rewards">
                                ${rewards.map(reward => `<div class="reward-item">${reward}</div>`).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            formatObjective(objective) {
                if (typeof objective === 'string') return objective;
                if (objective.Description) return objective.Description;
                if (objective.Type) {
                    let text = objective.Type;
                    if (objective.Target) text += `: ${objective.Target}`;
                    if (objective.Number) text += ` (${objective.Number})`;
                    return text;
                }
                return JSON.stringify(objective);
            }

            formatRewards(quest) {
                const rewards = [];

                if (quest.Rewards_Gold) {
                    rewards.push(`üí∞ ${quest.Rewards_Gold} Gold`);
                }

                if (quest.Rewards_Favor) {
                    rewards.push(`‚≠ê ${quest.Rewards_Favor} Favor`);
                }

                if (quest.Rewards_XP) {
                    rewards.push(`üìà ${quest.Rewards_XP} XP`);
                }

                if (quest.Rewards_Items && quest.Rewards_Items.length > 0) {
                    rewards.push(`üéÅ ${quest.Rewards_Items.length} Item(s)`);
                }

                return rewards;
            }
        }

        // Inventory Browser
        class InventoryBrowser {
            constructor(dataLoader) {
                this.dataLoader = dataLoader;
                this.allItems = [];
                this.filteredItems = [];
            }

            async initialize() {
                if (!this.dataLoader.itemsData || !this.dataLoader.cdnItemsData) {
                    return;
                }

                // Build item list with details
                this.allItems = this.dataLoader.itemsData.Items.map(item => {
                    const itemDetails = this.dataLoader.getItemDetails(item.TypeID);
                    const vaultName = this.dataLoader.getVaultName(item.StorageVault);

                    return {
                        ...item,
                        details: itemDetails,
                        vaultName
                    };
                });

                this.filteredItems = [...this.allItems];
                this.render();
                this.updateStats();
            }

            updateStats() {
                const totalItems = this.allItems.reduce((sum, item) => sum + 1, 0);
                const totalValue = this.allItems.reduce((sum, item) => sum + ((item.Value || 0) * (item.StackSize || 1)), 0);
                const vaultCount = new Set(this.allItems.map(item => item.StorageVault)).size;

                document.getElementById('totalItems').textContent = totalItems.toLocaleString();
                document.getElementById('totalValue').textContent = totalValue.toLocaleString() + 'g';
                document.getElementById('vaultCount').textContent = vaultCount;

                document.getElementById('inventoryStats').style.display = 'grid';
                document.getElementById('inventorySearchBar').style.display = 'block';
            }

            search(query) {
                const lowerQuery = query.toLowerCase();
                this.filteredItems = this.allItems.filter(item => {
                    return (
                        item.Name?.toLowerCase().includes(lowerQuery) ||
                        item.vaultName?.toLowerCase().includes(lowerQuery) ||
                        item.details?.Name?.toLowerCase().includes(lowerQuery)
                    );
                });
                this.render();
            }

            render() {
                const container = document.getElementById('inventoryList');

                if (this.filteredItems.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">üéí</div>
                            <h3>No items found</h3>
                            <p>Try adjusting your search or load items data.</p>
                        </div>
                    `;
                    return;
                }

                // Group items by StorageVault
                const groupedItems = this.groupByVault(this.filteredItems);

                // Render accordions for each vault
                container.innerHTML = Object.entries(groupedItems)
                    .sort(([a], [b]) => a.localeCompare(b))
                    .map(([vault, items]) => this.renderVaultAccordion(vault, items))
                    .join('');

                // Add click handlers for accordions
                this.attachAccordionHandlers();
            }

            groupByVault(items) {
                const grouped = {};
                for (const item of items) {
                    const vault = item.vaultName || 'Unknown Vault';
                    if (!grouped[vault]) {
                        grouped[vault] = [];
                    }
                    grouped[vault].push(item);
                }
                return grouped;
            }

            renderVaultAccordion(vault, items) {
                const accordionId = `vault-${vault.replace(/\s+/g, '-').toLowerCase()}`;
                const totalValue = items.reduce((sum, item) => sum + ((item.Value || 0) * (item.StackSize || 1)), 0);
                const totalCount = items.reduce((sum, item) => sum + 1, 0);

                // Sort items by total value (descending)
                const sortedItems = [...items].sort((a, b) => {
                    const aTotal = (a.Value || 0) * (a.StackSize || 1);
                    const bTotal = (b.Value || 0) * (b.StackSize || 1);
                    return bTotal - aTotal;
                });

                return `
                    <div class="location-accordion">
                        <div class="accordion-header" data-accordion="${accordionId}">
                            <div class="accordion-title">
                                <span>üóÑÔ∏è ${vault}</span>
                                <span class="quest-count-badge">${totalCount} items</span>
                            </div>
                            <div class="accordion-icon">‚ñº</div>
                        </div>
                        <div id="${accordionId}" class="accordion-content">
                            <div class="accordion-quests">
                                ${sortedItems.map(item => this.renderItemCard(item)).join('')}
                                <div class="vault-summary">
                                    <span class="vault-summary-label">Total Value:</span>
                                    <span class="vault-summary-value">üí∞ ${totalValue.toLocaleString()}g</span>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }

            renderItemCard(item) {
                const perItemValue = item.Value || 0;
                const totalValue = perItemValue * (item.StackSize || 1);

                // Determine rarity class
                const rarity = item.Rarity || '';
                const rarityClass = rarity ? `rarity-${rarity.toLowerCase()}` : '';

                // Build details badges
                const detailBadges = [];

                if (rarity) {
                    detailBadges.push(`<span class="item-detail-badge">${rarity}</span>`);
                }

                if (item.RequiredLevel || item.Level) {
                    const level = item.RequiredLevel || item.Level;
                    detailBadges.push(`<span class="item-detail-badge">Lvl ${level}</span>`);
                }

                if (item.EquipSlot || item.Slot) {
                    const slot = item.EquipSlot || item.Slot;
                    detailBadges.push(`<span class="item-detail-badge">${slot}</span>`);
                }

                return `
                    <div class="item-card ${rarityClass}">
                        <div class="item-header">
                            <div class="item-name">${item.Name || 'Unknown Item'}</div>
                            ${item.StackSize > 1 ? `<span class="item-stack">√ó${item.StackSize}</span>` : ''}
                        </div>
                        <div class="item-value">
                            üí∞ ${totalValue.toLocaleString()}g
                            ${item.StackSize > 1 ? ` (${perItemValue.toFixed(1)}g each)` : ''}
                        </div>
                        ${detailBadges.length > 0 ? `
                            <div class="item-details">
                                ${detailBadges.join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            attachAccordionHandlers() {
                const container = document.getElementById('inventoryList');
                const headers = container.querySelectorAll('.accordion-header');
                headers.forEach(header => {
                    header.addEventListener('click', () => {
                        const accordionId = header.getAttribute('data-accordion');
                        const content = document.getElementById(accordionId);

                        // Toggle active state
                        header.classList.toggle('active');
                        content.classList.toggle('active');
                    });
                });
            }
        }

        function loadVendorData() {
            try { return JSON.parse(localStorage.getItem('gorgon-vendor-data') || '{}'); }
            catch { return {}; }
        }

        function saveVendorData(data) {
            localStorage.setItem('gorgon-vendor-data', JSON.stringify(data));
        }

        // Regions to pin to the top of the Stores list (in order), rest sort alphabetically
        const STORE_PINNED_REGIONS = ['Serbule', 'Red Wing Casino', 'Eltibule'];

        // Store Browser
        class StoreBrowser {
            constructor(dataLoader) {
                this.dataLoader = dataLoader;
                this.storeNPCs = [];
                this.vendorData = loadVendorData();
                this.resetTicker = null;

                // Canonical favor level ordering (low ‚Üí high)
                this.FAVOR_ORDER = [
                    'Despised', 'Disliked', 'Neutral', 'Comfortable',
                    'Friends', 'CloseFriends', 'BestFriends', 'LikeFamily', 'SoulMates'
                ];
            }

            initialize() {
                if (!this.dataLoader.npcsData) return;

                this.storeNPCs = [];
                this.vendorData = loadVendorData();

                for (const [key, npc] of Object.entries(this.dataLoader.npcsData)) {
                    if (!npc.Services || !Array.isArray(npc.Services)) continue;

                    const storeService = npc.Services.find(s => s.Type === 'Store');
                    if (!storeService) continue;
                    if (!storeService.CapIncreases || storeService.CapIncreases.length === 0) continue;

                    // Skip vendors with no buy categories (entries only have level:value, not level:value:types)
                    const hasBuyTypes = storeService.CapIncreases.some(line => (line.match(/:/g) || []).length >= 2);
                    // if (!hasBuyTypes) continue;

                    // Match character favor level ‚Äî character stores NPC keys like "NPC_CharlesThompson"
                    const charNPC = this.dataLoader.characterData?.NPCs?.[key];
                    const favorLevel = charNPC?.FavorLevel || null;

                    this.storeNPCs.push({
                        key,
                        npc,
                        storeService,
                        favorLevel,
                        area: npc.AreaFriendlyName || npc.AreaName || 'Unknown Region'
                    });
                }

                this.render();
            }

            render() {
                const container = document.getElementById('storeList');

                if (this.storeNPCs.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">üõí</div>
                            <h3>No store data loaded</h3>
                            <p>Load character data to see merchant stores.</p>
                        </div>
                    `;
                    return;
                }

                // Group by region
                const byRegion = {};
                for (const entry of this.storeNPCs) {
                    const region = entry.area;
                    if (!byRegion[region]) byRegion[region] = [];
                    byRegion[region].push(entry);
                }

                container.innerHTML = Object.entries(byRegion)
                    .sort(([a], [b]) => {
                        const aPin = STORE_PINNED_REGIONS.indexOf(a);
                        const bPin = STORE_PINNED_REGIONS.indexOf(b);
                        if (aPin !== -1 && bPin !== -1) return aPin - bPin;
                        if (aPin !== -1) return -1;
                        if (bPin !== -1) return 1;
                        return a.localeCompare(b);
                    })
                    .map(([region, npcs]) => this.renderRegionAccordion(region, npcs))
                    .join('');

                this.attachHandlers();
                this.startResetTicker();
            }

            renderRegionAccordion(region, npcs) {
                const accordionId = `store-region-${region.replace(/\W+/g, '-').toLowerCase()}`;
                // Sort NPCs alphabetically within each region
                const sorted = [...npcs].sort((a, b) => (a.npc.Name || a.key).localeCompare(b.npc.Name || b.key));

                return `
                    <div class="location-accordion">
                        <div class="accordion-header" data-accordion="${accordionId}">
                            <div class="accordion-title">
                                <span>üìç ${region}</span>
                                <span class="quest-count-badge">${npcs.length} merchant${npcs.length !== 1 ? 's' : ''}</span>
                            </div>
                            <div class="accordion-icon">‚ñº</div>
                        </div>
                        <div id="${accordionId}" class="accordion-content">
                            <div class="stores-region-npcs">
                                <table class="store-table">
                                    <thead>
                                        <tr>
                                            <th>Merchant</th>
                                            <th>Favor</th>
                                            <th>Cap</th>
                                            <th>Resets</th>
                                            <th>Buys</th>
                                            <th></th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${sorted.map(entry => this.renderNPCCard(entry)).join('')}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                `;
            }

            formatTimeRemaining(ms) {
                if (ms <= 0) return 'Ready';
                const s = Math.floor(ms / 1000);
                const d = Math.floor(s / 86400);
                const h = Math.floor((s % 86400) / 3600);
                const m = Math.floor((s % 3600) / 60);
                const parts = [];
                if (d > 0) parts.push(`${d}d`);
                if (h > 0) parts.push(`${h}h`);
                if (m > 0 || parts.length === 0) parts.push(`${m}m`);
                return parts.join(' ');
            }

            updateRowCells(row, key) {
                const tracked = this.vendorData[key] || {};
                const remaining = tracked.remaining !== undefined ? tracked.remaining : null;
                const resetAt = tracked.resetAt || null;

                const entry = this.storeNPCs.find(e => e.key === key);
                if (!entry) return;
                const parsedCaps = this.parseCaps(entry.storeService).filter(p => p.favorLevel !== 'Despised');
                const currentCap = entry.favorLevel ? parsedCaps.find(p => p.favorLevel === entry.favorLevel) : null;

                const capCell = row.querySelector('.col-cap');
                if (currentCap) {
                    if (remaining !== null) {
                        const pct = remaining / currentCap.cap;
                        const cls = pct > 0.5 ? 'remaining-high' : pct > 0.2 ? 'remaining-med' : 'remaining-low';
                        capCell.innerHTML = `<span class="${cls}">${remaining.toLocaleString()}g</span> / ${currentCap.cap.toLocaleString()}g`;
                    } else {
                        capCell.innerHTML = `üí∞ ${currentCap.cap.toLocaleString()}g`;
                    }
                    capCell.className = 'col-cap';
                }

                const resetCell = row.querySelector('.col-reset');
                if (resetAt) {
                    const ms = resetAt - Date.now();
                    if (ms <= 0) {
                        resetCell.textContent = 'Ready';
                        resetCell.className = 'col-reset reset-ready';
                    } else {
                        resetCell.textContent = this.formatTimeRemaining(ms);
                        resetCell.className = 'col-reset';
                    }
                } else {
                    resetCell.textContent = '';
                    resetCell.className = 'col-reset';
                }
            }

            startResetTicker() {
                if (this.resetTicker) clearInterval(this.resetTicker);
                this.resetTicker = setInterval(() => {
                    const container = document.getElementById('storeList');
                    if (!container) return;
                    container.querySelectorAll('tr[data-npc-key]').forEach(row => {
                        const key = row.getAttribute('data-npc-key');
                        const tracked = this.vendorData[key];
                        if (!tracked?.resetAt) return;
                        const resetCell = row.querySelector('.col-reset');
                        if (!resetCell) return;
                        const ms = tracked.resetAt - Date.now();
                        if (ms <= 0) {
                            resetCell.textContent = 'Ready';
                            resetCell.className = 'col-reset reset-ready';
                        } else {
                            resetCell.textContent = this.formatTimeRemaining(ms);
                            resetCell.className = 'col-reset';
                        }
                    });
                }, 30000);
            }

            findNPCKeyByInternalKey(internalKey) {
                if (!internalKey) return null;
                // Direct key match ‚Äî most reliable, no CDN field guessing needed
                return this.storeNPCs.some(en => en.key === internalKey) ? internalKey : null;
            }

            findNPCKeyById(npcId) {
                if (npcId == null) return null;
                const id = Number(npcId);
                // CDN npc objects may use various field names for their numeric ID
                const found = this.storeNPCs.find(en =>
                    en.npc.ID === id || en.npc.NPCID === id || en.npc.NpcId === id
                );
                return found ? found.key : null;
            }

            findNPCKeyByDescription(desc) {
                if (!desc) return null;
                // Match against the vendor's store service description
                const found = this.storeNPCs.find(en =>
                    (en.storeService?.ServiceDescription === desc) ||
                    (en.npc.Services || []).some(s =>
                        s.ServiceDescription === desc || s.Description === desc
                    )
                );
                return found ? found.key : null;
            }

            findNPCKeyByName(displayName) {
                if (!displayName) return null;
                const lower = displayName.toLowerCase();
                let found = this.storeNPCs.find(en => en.npc.Name === displayName);
                if (found) return found.key;
                found = this.storeNPCs.find(en => (en.npc.Name || '').toLowerCase() === lower);
                return found ? found.key : null;
            }

            applyVendorCaptures(captures) {
                // Build a key‚Üírow map for in-place DOM updates
                const rowMap = {};
                document.querySelectorAll('#storeList tr[data-npc-key]').forEach(r => {
                    rowMap[r.getAttribute('data-npc-key')] = r;
                });

                let updated = false;
                for (const capture of Object.values(captures)) {
                    // Try matching strategies in priority order
                    const key =
                        this.findNPCKeyByInternalKey(capture.npcInternalKey) ||
                        this.findNPCKeyById(capture.npcId) ||
                        this.findNPCKeyByDescription(capture.description) ||
                        this.findNPCKeyByName(capture.vendorName);
                    if (!key) continue;

                    const existing = this.vendorData[key] || {};
                    const capAt = capture.capturedAt || 0;
                    if (capAt <= (existing.capturedAt || 0)) continue;

                    this.vendorData[key] = {
                        ...existing,
                        remaining: capture.remaining != null ? Math.round(capture.remaining) : existing.remaining,
                        capturedAt: capAt,
                    };
                    if (capture.resetAt) {
                        this.vendorData[key].resetAt = capture.resetAt;
                    }

                    if (rowMap[key]) this.updateRowCells(rowMap[key], key);
                    updated = true;

                    const label = capture.vendorName || `NPC#${capture.npcId}`;
                    const remStr = capture.remaining != null ? `${Math.round(capture.remaining)}g` : '?';
                    showCaptureToast(`Auto-filled: ${label} ‚Äî ${remStr} remaining`);
                }

                if (updated) saveVendorData(this.vendorData);
            }

            parseCaps(storeService) {
                return (storeService.CapIncreases || []).map(line => {
                    const colonIdx = line.indexOf(':');
                    const secondColonIdx = line.indexOf(':', colonIdx + 1);
                    const fLevel = line.substring(0, colonIdx);
                    const cap = (secondColonIdx >= 0 ? parseInt(line.substring(colonIdx + 1, secondColonIdx)) : parseInt(line.substring(colonIdx + 1))) || 0;
                    const buyTypes = secondColonIdx >= 0 ? line.substring(secondColonIdx + 1).split(',') : ['Any'];
                    return { favorLevel: fLevel, cap, buyTypes };
                });
            }

            renderNPCCard(entry) {
                const { key, npc, storeService, favorLevel } = entry;
                const name = npc.Name || key;

                const parsedCaps = this.parseCaps(storeService).filter(p => p.favorLevel !== 'Despised');
                const currentCap = favorLevel ? parsedCaps.find(p => p.favorLevel === favorLevel) : null;
                const capClass = currentCap ? '' : 'no-cap';

                const friendsIdx = this.FAVOR_ORDER.indexOf('Friends');
                const refCap = parsedCaps.find(p => this.FAVOR_ORDER.indexOf(p.favorLevel) >= friendsIdx) || parsedCaps[0];
                const buysText = refCap ? refCap.buyTypes.join(', ') : '';

                const favorBadgeHtml = favorLevel
                    ? `<span class="favor-badge favor-${favorLevel.toLowerCase()}">${favorLevel}</span>`
                    : `<span class="favor-badge favor-unknown">Not Met</span>`;

                // Tracker data from localStorage
                const tracked = this.vendorData[key] || {};
                const remaining = tracked.remaining !== undefined ? tracked.remaining : null;
                const resetAt = tracked.resetAt || null;

                // Cap cell
                let capHtml;
                if (currentCap) {
                    if (remaining !== null) {
                        const pct = remaining / currentCap.cap;
                        const cls = pct > 0.5 ? 'remaining-high' : pct > 0.2 ? 'remaining-med' : 'remaining-low';
                        capHtml = `<span class="${cls}">${remaining.toLocaleString()}g</span> / ${currentCap.cap.toLocaleString()}g`;
                    } else {
                        capHtml = `üí∞ ${currentCap.cap.toLocaleString()}g`;
                    }
                } else {
                    capHtml = '‚Äî';
                }

                // Reset cell
                let resetHtml = '', resetColClass = 'col-reset';
                if (resetAt) {
                    const ms = resetAt - Date.now();
                    if (ms <= 0) { resetHtml = 'Ready'; resetColClass += ' reset-ready'; }
                    else resetHtml = this.formatTimeRemaining(ms);
                }

                return `
                    <tr data-npc-key="${key}">
                        <td class="col-name"><a href="https://wiki.projectgorgon.com/wiki/?search=${encodeURIComponent(name)}" target="_blank" rel="noopener noreferrer" style="color: inherit; text-decoration: none;" onmouseover="this.style.color='#667eea';this.style.textDecoration='underline'" onmouseout="this.style.color='inherit';this.style.textDecoration='none'">${name}</a></td>
                        <td class="col-favor">${favorBadgeHtml}</td>
                        <td class="col-cap ${capClass}">${capHtml}</td>
                        <td class="${resetColClass}">${resetHtml}</td>
                        <td class="col-buys">${buysText}</td>
                        <td class="col-actions">
                            <div style="display:flex;gap:4px;justify-content:flex-end;align-items:center;">
                                <button class="tracker-btn" title="Track remaining/reset">‚úè</button>
                                <div class="tooltip-container">
                                    <button class="tooltip-btn">?</button>
                                    <div class="tooltip-content">
                                        <div class="tooltip-title">All Favor Tiers</div>
                                        ${this.renderCapTable(parsedCaps, favorLevel)}
                                        ${npc.Preferences && npc.Preferences.length > 0 ? `
                                            <div class="tooltip-title tooltip-title-divider">Gift Preferences</div>
                                            ${this.renderPreferencesTable(npc.Preferences)}
                                        ` : ''}
                                    </div>
                                </div>
                            </div>
                        </td>
                    </tr>
                `;
            }

            renderCapTable(parsedCaps, currentFavorLevel) {
                if (parsedCaps.length === 0) {
                    return '<p style="padding: 12px; color: #6c757d; font-size: 0.9em;">No cap data available.</p>';
                }

                const currentFavorIndex = this.FAVOR_ORDER.indexOf(currentFavorLevel);

                const rows = parsedCaps.map(cap => {
                    const capFavorIndex = this.FAVOR_ORDER.indexOf(cap.favorLevel);
                    let rowClass = '';
                    if (currentFavorLevel) {
                        if (cap.favorLevel === currentFavorLevel) {
                            rowClass = 'cap-row-current';
                        } else if (capFavorIndex < currentFavorIndex) {
                            rowClass = 'cap-row-unlocked';
                        } else {
                            rowClass = 'cap-row-locked';
                        }
                    }
                    return `
                        <tr class="${rowClass}">
                            <td>${cap.favorLevel}</td>
                            <td>${cap.cap.toLocaleString()}g</td>
                        </tr>
                    `;
                }).join('');

                return `
                    <table class="cap-table">
                        <thead>
                            <tr>
                                <th>Favor Level</th>
                                <th>Money Cap</th>
                            </tr>
                        </thead>
                        <tbody>${rows}</tbody>
                    </table>
                `;
            }

            renderPreferencesTable(preferences) {
                // Sort by Pref descending so highest favor-per-gift items appear first
                const sorted = [...preferences].sort((a, b) => (b.Pref || 0) - (a.Pref || 0));

                const rows = sorted.map(pref => {
                    const desire = pref.Desire || '';
                    const desireStyle = desire === 'Love'
                        ? 'color: #155724; font-weight: 600;'
                        : desire === 'Hate' ? 'color: #721c24; font-weight: 600;' : '';
                    return `
                        <tr>
                            <td>${pref.Name || ''}</td>
                            <td style="${desireStyle}">${desire}</td>
                            <td>${pref.Pref !== undefined ? pref.Pref : ''}</td>
                        </tr>
                    `;
                }).join('');

                return `
                    <table class="cap-table">
                        <thead>
                            <tr>
                                <th>Gift</th>
                                <th>Desire</th>
                                <th>Favor/Gift</th>
                            </tr>
                        </thead>
                        <tbody>${rows}</tbody>
                    </table>
                `;
            }

            attachHandlers() {
                const container = document.getElementById('storeList');

                // Region accordion headers
                container.querySelectorAll('.accordion-header').forEach(header => {
                    header.addEventListener('click', () => {
                        const id = header.getAttribute('data-accordion');
                        const content = document.getElementById(id);
                        header.classList.toggle('active');
                        content.classList.toggle('active');
                    });
                });

                // Tooltip toggle buttons
                container.querySelectorAll('.tooltip-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const tooltipContainer = btn.closest('.tooltip-container');
                        const isOpen = tooltipContainer.classList.toggle('tooltip-open');
                        btn.classList.toggle('tooltip-active', isOpen);
                    });
                });

                // Close open tooltips when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.tooltip-container')) {
                        container.querySelectorAll('.tooltip-container.tooltip-open').forEach(tc => {
                            tc.classList.remove('tooltip-open');
                            tc.querySelector('.tooltip-btn')?.classList.remove('tooltip-active');
                        });
                    }
                }, { capture: false });

                // Tracker pencil button ‚Äî open modal
                container.querySelectorAll('.tracker-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const row = btn.closest('tr');
                        const key = row.getAttribute('data-npc-key');
                        const entry = this.storeNPCs.find(en => en.key === key);
                        const tracked = this.vendorData[key] || {};
                        const remaining = tracked.remaining !== undefined ? tracked.remaining : '';
                        let days = '', hours = '', mins = '';
                        if (tracked.resetAt && tracked.resetAt > Date.now()) {
                            const s = Math.floor((tracked.resetAt - Date.now()) / 1000);
                            days  = Math.floor(s / 86400) || '';
                            hours = Math.floor((s % 86400) / 3600) || '';
                            mins  = Math.floor((s % 3600) / 60) || '';
                        }
                        document.getElementById('trackerModalTitle').textContent = entry?.npc?.Name || key;
                        document.getElementById('trackerModalRemaining').value = remaining;
                        document.getElementById('trackerModalDays').value = days;
                        document.getElementById('trackerModalHours').value = hours;
                        document.getElementById('trackerModalMins').value = mins;
                        this._modalKey = key;
                        this._modalRow = row;
                        document.getElementById('trackerModal').style.display = 'flex';
                        document.getElementById('trackerModalRemaining').focus();
                    });
                });

                // Modal close / save / clear ‚Äî assigned with onclick so re-renders don't stack listeners
                document.getElementById('trackerModalCloseBtn').onclick = () => {
                    document.getElementById('trackerModal').style.display = 'none';
                };

                document.getElementById('trackerModalSave').onclick = () => {
                    const remainingVal = document.getElementById('trackerModalRemaining').value;
                    const d = parseInt(document.getElementById('trackerModalDays').value)  || 0;
                    const h = parseInt(document.getElementById('trackerModalHours').value) || 0;
                    const m = parseInt(document.getElementById('trackerModalMins').value)  || 0;
                    const remaining = remainingVal !== '' ? parseInt(remainingVal) : undefined;
                    const totalMs = (d * 86400 + h * 3600 + m * 60) * 1000;
                    const resetAt = totalMs > 0 ? Date.now() + totalMs : null;
                    this.vendorData[this._modalKey] = { remaining, resetAt };
                    saveVendorData(this.vendorData);
                    this.updateRowCells(this._modalRow, this._modalKey);
                    document.getElementById('trackerModal').style.display = 'none';
                };

                document.getElementById('trackerModalClear').onclick = () => {
                    delete this.vendorData[this._modalKey];
                    saveVendorData(this.vendorData);
                    this.updateRowCells(this._modalRow, this._modalKey);
                    document.getElementById('trackerModal').style.display = 'none';
                };
            }
        }

        // Show a brief non-blocking toast when vendor captures auto-fill data
        function showCaptureToast(message) {
            const toast = document.getElementById('captureToast');
            if (!toast) return;
            toast.textContent = message;
            toast.style.display = 'block';
            clearTimeout(toast._hideTimer);
            toast._hideTimer = setTimeout(() => { toast.style.display = 'none'; }, 4000);
        }

        // ‚îÄ‚îÄ Player.log Watcher ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        let playerLogFileHandle = null;
        let playerLogOffset = 0;
        let playerLogPollTimer = null;

        async function savePlayerLogHandle(handle) {
            try {
                const db = await openHandlesDB();
                const tx = db.transaction('handles', 'readwrite');
                tx.objectStore('handles').put(handle, 'playerLogFile');
                await new Promise(resolve => { tx.oncomplete = resolve; });
            } catch (e) { /* non-critical */ }
        }

        async function getSavedPlayerLogHandle() {
            try {
                const db = await openHandlesDB();
                return await new Promise(resolve => {
                    const req = db.transaction('handles', 'readonly').objectStore('handles').get('playerLogFile');
                    req.onsuccess = (e) => resolve(e.target.result || null);
                    req.onerror = () => resolve(null);
                });
            } catch (e) { return null; }
        }

        // Maps numeric npcId ‚Üí internal key e.g. 12485 ‚Üí "NPC_Ragabir"
        // Populated by ProcessStartInteraction lines that precede vendor screen opens.
        const npcIdToKeyMap = {};

        const RE_START_INTERACTION = /LocalPlayer: ProcessStartInteraction\((\d+),.*?"([^"]+)"\)/;
        const RE_VENDOR_SCREEN     = /LocalPlayer: ProcessVendorScreen\((\d+), (\w+), (\d+), (\d+), (\d+), "([^"]*)"/;

        async function pollPlayerLog() {
            if (!playerLogFileHandle) return;
            try {
                const file = await playerLogFileHandle.getFile();
                if (file.size > playerLogOffset) {
                    const newBytes = file.size - playerLogOffset;
                    const text = await file.slice(playerLogOffset).text();
                    const lines = text.split('\n');
                    let vendorLinesFound = 0;

                    for (const line of lines) {
                        // Build the id‚Üíkey map from interaction lines
                        const im = RE_START_INTERACTION.exec(line);
                        if (im) {
                            const [, id, internalKey] = im;
                            npcIdToKeyMap[parseInt(id)] = internalKey;
                            console.log(`[player.log] Mapped NPC#${id} ‚Üí ${internalKey}`);
                            continue;
                        }

                        // Parse vendor screen events
                        const vm = RE_VENDOR_SCREEN.exec(line);
                        if (vm) {
                            const [, npcId, favorLevel, remaining, resetAt, cap, description] = vm;
                            const id = parseInt(npcId);
                            const internalKey = npcIdToKeyMap[id] || null;
                            const capture = {
                                npcId:       id,
                                npcInternalKey: internalKey,
                                favorLevel,
                                remaining:   parseInt(remaining),
                                resetAt:     parseInt(resetAt),
                                cap:         parseInt(cap),
                                description,
                                capturedAt:  Date.now(),
                            };
                            vendorLinesFound++;
                            console.log(
                                `[vendor] NPC#${id} (${internalKey || '?'}) ${favorLevel}` +
                                ` remaining=${capture.remaining} cap=${capture.cap}` +
                                ` resetAt=${new Date(capture.resetAt).toLocaleString()}`,
                                capture
                            );
                            storeBrowser.applyVendorCaptures({ [id]: capture });
                        }
                    }

                    if (vendorLinesFound || newBytes > 0) {
                        console.log(`[player.log] +${newBytes}B, ${lines.length} lines, ${vendorLinesFound} vendor event(s)`);
                    }
                }
                playerLogOffset = file.size;
            } catch (e) {
                console.warn('[player.log] poll error:', e);
            }
        }

        function startPlayerLogWatcher() {
            if (playerLogPollTimer) clearInterval(playerLogPollTimer);
            playerLogPollTimer = setInterval(pollPlayerLog, 2000);
            pollPlayerLog(); // immediate first poll
        }

        function updatePlayerLogStatus(watching) {
            const btn = document.getElementById('selectPlayerLogBtn');
            const status = document.getElementById('playerLogStatus');
            if (!btn) return;
            if (watching) {
                btn.textContent = '‚óè Player.log';
                btn.classList.add('player-log-active');
                if (status) status.textContent = 'Watching ‚Äî open a vendor shop in-game to capture data.';
            } else {
                btn.textContent = 'üìã Watch Player.log';
                btn.classList.remove('player-log-active');
                if (status) status.textContent = 'Select Player.log to auto-capture vendor data when you open shops in-game.';
            }
        }

        async function selectPlayerLogFile() {
            try {
                const pickerOpts = { multiple: false, id: 'gorgon-playerlog' };
                const saved = await getSavedPlayerLogHandle();
                if (saved) pickerOpts.startIn = saved;
                const [handle] = await window.showOpenFilePicker(pickerOpts);
                playerLogFileHandle = handle;
                await savePlayerLogHandle(handle);
                // Start from end of file ‚Äî only capture new events going forward
                playerLogOffset = (await handle.getFile()).size;
                startPlayerLogWatcher();
                updatePlayerLogStatus(true);
            } catch (e) {
                if (e.name !== 'AbortError') alert('Error selecting Player.log: ' + e.message);
            }
        }

        // Application initialization
        let dataLoader = new DataLoader();
        let questBrowser = new QuestBrowser(dataLoader);
        let inventoryBrowser = new InventoryBrowser(dataLoader);
        let storeBrowser = new StoreBrowser(dataLoader);
        let reportsDirectoryHandle = null;

        function showStatus(message, type = 'loading') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }

        async function handleCharacterFileLoad(file) {
            try {
                showStatus('Loading character data...', 'loading');

                await dataLoader.loadCharacterFile(file);
                showStatus('Loading quest database from CDN...', 'loading');

                await dataLoader.loadQuestData();
                showStatus(`‚úì Loaded ${dataLoader.characterData.Character}'s data with ${dataLoader.characterData.ActiveQuests.length} active quests`, 'success');

                await questBrowser.initialize();
                storeBrowser.initialize();
            } catch (error) {
                showStatus(`‚úó Error: ${error.message}`, 'error');
                console.error('Load error:', error);
            }
        }

        async function handleItemsFileLoad(file) {
            try {
                showStatus('Loading items data...', 'loading');

                await dataLoader.loadItemsFile(file);
                showStatus('Loading item database from CDN...', 'loading');

                await dataLoader.loadInventoryData();
                showStatus(`‚úì Loaded ${dataLoader.itemsData.Items.length} items from storage`, 'success');

                await inventoryBrowser.initialize();
            } catch (error) {
                showStatus(`‚úó Error: ${error.message}`, 'error');
                console.error('Load error:', error);
            }
        }

        // Persist the chosen directory handle in IndexedDB so the picker
        // remembers the location even when the page is opened via file://.
        async function openHandlesDB() {
            return new Promise((resolve, reject) => {
                const req = indexedDB.open('GorgonTrackerDB', 1);
                req.onupgradeneeded = (e) => e.target.result.createObjectStore('handles');
                req.onsuccess = (e) => resolve(e.target.result);
                req.onerror = (e) => reject(e.target.error);
            });
        }

        async function saveDirectoryHandle(handle) {
            try {
                const db = await openHandlesDB();
                const tx = db.transaction('handles', 'readwrite');
                tx.objectStore('handles').put(handle, 'reportsDir');
                await new Promise(resolve => { tx.oncomplete = resolve; });
            } catch (e) { /* non-critical */ }
        }

        async function getSavedDirectoryHandle() {
            try {
                const db = await openHandlesDB();
                return await new Promise(resolve => {
                    const req = db.transaction('handles', 'readonly').objectStore('handles').get('reportsDir');
                    req.onsuccess = (e) => resolve(e.target.result || null);
                    req.onerror = () => resolve(null);
                });
            } catch (e) { return null; }
        }

        async function selectReportsFolder() {
            try {
                const savedHandle = await getSavedDirectoryHandle();
                const pickerOpts = { id: 'gorgon-reports', mode: 'read' };
                if (savedHandle) pickerOpts.startIn = savedHandle;
                reportsDirectoryHandle = await window.showDirectoryPicker(pickerOpts);
                await saveDirectoryHandle(reportsDirectoryHandle);
                const btn = document.getElementById('selectFolderBtn');
                btn.textContent = '‚úì Folder Selected';
                btn.style.background = '#d4edda';
                btn.style.color = '#155724';
                btn.style.borderColor = '#28a745';
                await loadAllDataFromDirectory(reportsDirectoryHandle);
            } catch (e) {
                if (e.name !== 'AbortError') {
                    showStatus(`‚úó Folder error: ${e.message}`, 'error');
                }
            }
        }

        async function loadAllDataFromDirectory(dirHandle) {
            try {
                showStatus('Loading character data from folder...', 'loading');
                await dataLoader.loadCharacterFromDirectory(dirHandle);

                showStatus('Loading items data from folder...', 'loading');
                await dataLoader.loadItemsFromDirectory(dirHandle);

                showStatus('Loading reference data from CDN...', 'loading');
                await dataLoader.loadQuestData();
                await dataLoader.loadInventoryData();

                await questBrowser.initialize();
                await inventoryBrowser.initialize();
                storeBrowser.initialize();

                showStatus(
                    `‚úì Loaded ${dataLoader.characterData.Character}'s data from folder: ${dataLoader.characterData.ActiveQuests.length} quests, ${dataLoader.itemsData.Items.length} items`,
                    'success'
                );
            } catch (error) {
                showStatus(`‚úó Error: ${error.message}`, 'error');
                console.error('Load error:', error);
            }
        }

        async function loadAllDataFromAPI() {
            try {
                showStatus('Loading game data from disk...', 'loading');

                showStatus('Loading quest database from CDN...', 'loading');
                await dataLoader.loadQuestData();

                showStatus('Loading item database from CDN...', 'loading');
                await dataLoader.loadInventoryData();

                // Initialize all browsers
                await questBrowser.initialize();
                await inventoryBrowser.initialize();
                storeBrowser.initialize();

                showStatus(
                    `‚úì Loaded CDN data: Please load character data!`,
                    'success'
                );

            } catch (error) {
                showStatus(`‚úó Error: ${error.message}. Use Manual File Loading below.`, 'error');
                console.error('Load error:', error);
            }
        }

        // Tab switching
        function switchTab(tabName, updateHash = true) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.getAttribute('data-tab') === tabName) {
                    tab.classList.add('active');
                }
            });

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabName).classList.add('active');

            // Update URL hash
            if (updateHash) {
                window.location.hash = tabName;
            }
        }

        // Handle hash changes (browser back/forward)
        function handleHashChange() {
            const hash = window.location.hash.slice(1); // Remove '#'
            const validTabs = ['quests', 'inventory', 'stores', 'maps'];

            if (hash && validTabs.includes(hash)) {
                switchTab(hash, false); // Don't update hash again to avoid loop
            }
        }

        // Initialize tab from URL hash on page load
        function initializeTabFromHash() {
            const hash = window.location.hash.slice(1);
            const validTabs = ['quests', 'inventory', 'stores', 'maps'];

            if (hash && validTabs.includes(hash)) {
                switchTab(hash, false);
            }
        }

        // Event listeners
        document.getElementById('characterFile').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleCharacterFileLoad(file);
            }
        });

        document.getElementById('itemsFile').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleItemsFileLoad(file);
            }
        });

        document.getElementById('questSearch').addEventListener('input', (e) => {
            questBrowser.search(e.target.value);
        });

        document.getElementById('inventorySearch').addEventListener('input', (e) => {
            inventoryBrowser.search(e.target.value);
        });

        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                switchTab(tab.getAttribute('data-tab'));
            });
        });

        document.getElementById('reloadBtn').addEventListener('click', () => {
            if (reportsDirectoryHandle) {
                loadAllDataFromDirectory(reportsDirectoryHandle);
            }
        });

        // Handle hash changes for tab navigation
        window.addEventListener('hashchange', handleHashChange);

        // Initialize tab from URL hash
        initializeTabFromHash();

        // Auto-load data on page load
        loadAllDataFromAPI();

        // Restore saved handles if permission was already granted this session
        (async () => {
            const [savedFolder, savedLog] = await Promise.all([
                getSavedDirectoryHandle(),
                getSavedPlayerLogHandle(),
            ]);

            if (savedFolder) {
                try {
                    const perm = await savedFolder.queryPermission({ mode: 'read' });
                    if (perm === 'granted') {
                        reportsDirectoryHandle = savedFolder;
                        const btn = document.getElementById('selectFolderBtn');
                        if (btn) { btn.textContent = '‚úì Folder Selected'; btn.style.background = '#d4edda'; btn.style.color = '#155724'; btn.style.borderColor = '#28a745'; }
                        loadAllDataFromDirectory(savedFolder);
                    }
                } catch { /* stale handle, ignore */ }
            }

            if (savedLog) {
                try {
                    const perm = await savedLog.queryPermission({ mode: 'read' });
                    if (perm === 'granted') {
                        playerLogFileHandle = savedLog;
                        playerLogOffset = (await savedLog.getFile()).size;
                        startPlayerLogWatcher();
                        updatePlayerLogStatus(true);
                    }
                } catch { /* stale handle, ignore */ }
            }
        })();

        // Show empty state initially
        document.getElementById('questList').innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">üìÅ</div>
                <h3>No character data loaded</h3>
                <p>Select your Character.json file or Reports folder above to get started.</p>
            </div>
        `;

        document.getElementById('inventoryList').innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">üìÅ</div>
                <h3>No items data loaded</h3>
                <p>Select your *_items_*.json file or Reports folderabove to get started.</p>
            </div>
        `;

        document.getElementById('storeList').innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">üõí</div>
                <h3>No store data loaded</h3>
                <p>Click Reload Game Data to load merchant stores.</p>
            </div>
        `;
        // Close tracker modal on Escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') document.getElementById('trackerModal').style.display = 'none';
        });
    </script>

    <div id="trackerModal" class="tracker-modal-overlay" style="display:none;">
        <div class="tracker-modal">
            <div class="tracker-modal-header">
                <span class="tracker-modal-title" id="trackerModalTitle">Track Vendor</span>
                <button class="tracker-modal-close" id="trackerModalCloseBtn">‚úï</button>
            </div>
            <div class="tracker-modal-body">
                <div class="tracker-popup-label" style="margin-top:0">Remaining gold</div>
                <input type="number" id="trackerModalRemaining" class="tracker-remaining-input" placeholder="e.g. 5000" min="0">
                <div class="tracker-popup-label">Resets in</div>
                <div class="tracker-reset-inputs">
                    <input type="number" id="trackerModalDays"  placeholder="0" min="0"> d
                    <input type="number" id="trackerModalHours" placeholder="0" min="0" max="23"> h
                    <input type="number" id="trackerModalMins"  placeholder="0" min="0" max="59"> m
                </div>
            </div>
            <div class="tracker-modal-footer">
                <button class="tracker-save-btn" id="trackerModalSave">Save</button>
                <button class="tracker-clear-btn" id="trackerModalClear">Clear</button>
            </div>
        </div>
    </div>

    <div id="captureToast" class="capture-toast" style="display:none;"></div>
</body>
</html>
